/* Performance Analysis v3_0.sql
===================================
Purpose: To verify configuration settings and best practices
Assembled by: Sunshine Rodriguez
Version: 3.0
Orig Created: 12/20/2014
Last Modified: 1/9/23

   v3.0
	- modified to produce output that will go in the ticket
	- backup checksum check added
	- sharepoint flag added
	- default file type locations added
	- cleanup temp tables section at the end in case of failure before it completes
	- 2022 RTM released 11/16/2022; should be RS-supported on 2/16/2023		-11/21/22 SGR
	- added 2022 version identification - 11/21/22 SGR
	- typos 1/9/23 SGR
	- heaps language changed 1/12/23 SGR

   v2.8 (not released)
	- too many NC indexes 		-3/1/22 SGR
		- print stmt should have a count of unique dbs that have too many indexes	-3/1/22 SGR
	- log file is as large as or bigger than data file	-10/21/21 SGR
	- modify Dup Indexes to output one result set instead of 1 per database		-1/19/22 SGR
		- print stmt should have a count of unique dbs that have dup indexes	-3/1/22 SGR
	- fixed database name in missing index plan cache	-3/3/22 SGR
	- Heaps with NCIs vs NO NCIs	-3/3/22 -SGR
	- Backup and db owner only for dbs = ONLINE		-3/29/22 SGR
	- which databases show full text search enabled?	-3/4/22 SGR
	    - which datbases have full text catalogs?		-3/4/22 SGR
		- check index fragmentation where catalogs exist
	- query store (qds) - is actual operation mode the same as desired op mode	-4/4/22 SGR

   v2.7
	- corrected syntax output in misssing indexes from plan cache	-1/11/21 SGR
	- changed 2 part name to 3 part name in missing indexes from plan cache		-1/12/21 SGR
	- virtual_machine_type only available 2008 R2 SP1+ (not RTM)	-2/8/21 SGR
	- objects should be owned by 'sa' but 'sa' shoul also be disabled as best practice	
	- trace flag check to include start up flags, just because they are global doesn't mean they are in the startup parameters. global doesn't persist after restart unless part of startup param. CHANGE IN RESULTS BUT NOT REPORT	-2/17/21 SGR
	- add product update level 'CUn' (Applies to: SQL Server 2012 (11.x) through current version in updates beginning in late 2015)		-2/17/21 SGR
	- changed @bFragLevels to @bIdxLevels to control all index results		-2/18/21 SGR
	- added @bStatsLevels to show stats results for each database, only if enabled		-2/18/21 SGR
	- note about using db_id() in index fragmentation portion when compatibility level < 90		-3/1/21 SGR
	- ignore system/internal indexes for duplicate index check	-4/29/21 SGR
	- add tuning flag for PDM reviews		-5/18/21 SGR
	- removed unused indexes section  -7/15/21 SGR
		- REMOVED - unused indexes needs to look at all user dbs not just one		-2/17/21 SGR
		- REMOVED - ignore system/internal indexes for unused index check		-5/18/21 SGR

   v2.6
	- change trace flag check to >= 2016 instead of = 2016  -2/23/19 SGR
	- extended variable size for total IO dbs -2/17/19 SGR
	- now only checking statistics last update date on each database if index frag levels also being checked (@bFragLevels set at the top, defaulted to 0) -1/20 SGR
	- 2019 RTM released 11/4/2019; should be RS-supported on 2/4/2020 -1/4/20 SGR
		The Modern Servicing Model (MSM): Starting from SQL Server 2017 Service Packs will no longer be released as of Oct 24, 2017 -1/20/2020 SGR 
	- Changed Sophos check as specific loaded DLL wasn't picked up by query  -1/18/20 SGR
	- added 2019 version identification - 2/20 SGR
	- increased memNum decimal size to 15,2 from 5,2 -2/24/20 SGR
	- are full-text indexes being utilized? if not, ignore full-text crawl setting  -3/14/20 SGR
	- note about backup compression and encryption being used together AND below a certain version  -2/14/20 SGR
	- obsolete versions (< 2012) in supported version check -3/15/20 SGR
	- trace flag 3226 & 2371 checks (logging of successful backups in error log & thresholds to update stats, respectively)  -10/10/20 SGR
	- remote admin connections -10/10/20 SGR
	- added more version issues and their fixes  -10/17/20 SGR
	- added to risky SPs/CUs messages for 2017  -10/25/20 SGR

   v2.5.1
	- added code to ignore errors when executed in Azure SQL Managed Instance (no major changes) -1/12/2019 SGR
	- added code to ignore tempdb on integrity check...checks -1/12/2019 SGR
	- fixed output message for 2012 SP3/SP4 -1/19/19 SGR
	- 2012 SP4 updates: lock pages in memory and instant file initialization checks -1/20/19 SGR
	- 2014 SP3 released 10/30/18; should be Rackspace-supported on 1/30/2019   -1/26/19 SGR
	- changed database count variables to varchar(5) in various locations -1/26/19 SGR
    - increased max values for maxdop, max full-text range, and cost threshold for parallelism   -1/26/19 SGR

   v2.5 
	- changed variable size for cost threshold for parallelism -5/20/18 SGR
	- supported version check for 2016 SP2 -5/20/18 SGR
	- SQL Server start time -7/16/2018 SGR
	- add wait types related to newer versions of SQL Server (so far just AlwaysOn)  -11/4/2018 SGR
	    HADR_SYNC_COMMIT
		PARALLEL_REDO_FLOW_CONTROL
        PARALLEL_REDO_TRAN_TURN
	    DIRTY_PAGE_TABLE_LOCK
	- added is_encrypted to DB Settings results -9/24/18 SGR
	- fixed issue with @vmType in servers < 2008R2 -11/4/18 SGR

   v2.4.1
	- added getdate() to Messages tab -2/17/18 SGR
	- added to risky SPs/CUs messages for 2016 (TDE and backup compression)
	- added note to backup compression
	- rearranged version check details -3/4/18 SGR
	- output values for certain server level settings instead of 'VERIFY SETTINGS' -3/5/18 SGR

   v2.4
	- added versNumber for 2017
	- check for security update to address Meltdown and Spectre vulnerabilities (CVE 2017-5715, 2017-5753, 2017-5754); 
		Update will address SQL performance due to OS patches to address same vulnerabilities
	- changed VLF check to 500 -1/29/18 SGR
	- supported version check 2012 SP4 -1/29/18 SGR
	- supported version check 2017 RTM -1/29/18 SGR
	- added code for Amazon RDS -2/2/18 SGR
		- checks removed:
			- owner of object (dbs and jobs)
			- VLF count
			- last integrity check execution

   v2.3
	- version check confirmed -4/15/17 SGR (... not sure what this is ...)
	- OS vs SQL CPU -4/17/17 SGR
	- added code to ignore snapshots when querying sys.databases -4/29/17 SGR
	- is encryption enabled? -4/29/17 SGR
		- there shouldn't be backup compression on these databases (unless at least 2016 RTM CU7, 2016 SP1 CU4)
	- is this a VM? -6/5/17 SGR
	- is this HADR enabled? -6/5/17 SGR
		- what is the health of the AG and who are the replicas? -6/5/17 SGR
	- rearranged Max DOP to make sense logically. -6/24/17 SGR
	- check OS mem vs SQL mem. -6/30/17 SGR
	- minor changes made to handle case sensitive collation. -11/4/17 SGR

   v2.2
	- added code to prune duplicate indexes (unique vs non-unique). -11/6/16 SGR
	- 2016 SP1 updates: lock pages in memory and instant file initialization checks. -12/12/16 SGR
			- have to check for the version before checking if these are enabled.
			- 2016 SP1 -> 13.0.4001.0 or 13.1.4001.0

   v2.1
	- added risky SPs/CUs messages. -9/12/16 SGR
	- removed extra CRLFs in verifications output. -9/12/16 SGR
	- added SOPHOS~2.DLL. -9/23/16 SGR
	- added nocount for batch scope. -9/25/16 SGR
	- trace flag check not necessary for SQL 2016. -9/25/16 SGR

   v2.0
	- removed the OS checks section. -7/31/16 SGR
	- modified latest versions of SQL. -8/15/16 SGR
	- removed dbcc info msgs. -8/22/16 SGR

   v1.1
	- corrected DB I/O comments. -4/15/16 SGR
	- modified 'Version Check' section to provide physical memory values depending on SQL version. -4/25/16 SGR
	- corrected VLF code when dealing with db names that have dashes. -4/26/16 SGR
	- corrected trace flag 1117 status. -4/26/16 SGR 
	- removed the split in script so now all is run in one swoop; you can still toggle index frag portion but other than that...
	  one script for all. -5/19/16 SGR

   v1.0
	- added s.fill_factor to index frag script. -2/8/16 SGR



	*** I've decided to use a separate script (hopefully just one) for all Cloud Services (AWS, Azure, Google, etc.) since
	    those changes take longer for me to test which prevents me from getting this standard one out more quickly -11/4/2018 SGR
===================================
*/

set ansi_warnings off
set nocount on
go

declare @bShowSettingsResults bit, @bStatsLevels bit, @bIdxFragLevels bit, @bIdxLevels bit, @bPDM bit, @bIsAmazonRDS bit, @bIsAzureSQLDB bit, @bIsAzureSQLMI bit, @lastSQLRestart datetime, @bIsActionable bit, @bIsBestPracticeMet bit, @bIsSharePoint bit, @tMode tinyint

--CURSOR VARIABLE
declare @aitem varchar(max), @citem varchar(max), @category varchar(3), @acount tinyint, @ccount tinyint


--~~~~~~~~~~ SETTINGS THAT CAN BE CONFIGURED TO RUN THE SCRIPT ~~~~~~~~~~
set @bShowSettingsResults = 1	-- THIS PARAMETER WILL SHOW SETTINGS RESULTS IN GRID, MOSTLY FOR TESTING OR VERIFYING RESULTS
set @bIsSharePoint = 0		--IF SET TO 1, SHAREPOINT IS IN PLAY AND BEST PRACTICES RECS WILL REFLECT THAT
set @bIdxFragLevels = 1		--IF SET TO 1, CHECK INDEX FRAGMENTATION ON THE HIGHEST WRITE DB ONLY
set @bIdxLevels = 1   --IF SET TO 1, CHECK INDEX DETAILS (MISSING, TOO MANY, HEAPS, HYPOTHETICAL, ETC.)
set @bStatsLevels = 1	--IF SET TO 1, CHECK STATISTICS ON EVERY DATABASE; OTHERWISE, DO NOT CHECK STATSTICS
set @bPDM = 0	--IF SET TO 1, THIS REVIEW WILL RENDER RESULTS ONLY FOR PDM CUSTOMERS

--for easier configuration, set the mode
set @tMode = 0
/*  
	default = 0		-- run with the above settings
	limited = 1		-- no indexes, no stats
	simple = 2		-- shows some index (sans fragmentation), no stats 
	detailed = 3	-- shows some index (sans fragmentation), all statistics 
	all = 4			-- shows all index and all statistics
*/
if @tMode = 1
begin
	set @bIdxFragLevels = 0
	set @bIdxLevels = 0 
	set @bStatsLevels = 0
end
else if @tMode = 2
begin
	set @bIdxFragLevels = 0
	set @bIdxLevels = 1 
	set @bStatsLevels = 0
end
else if @tMode = 3
begin
	set @bIdxFragLevels = 0
	set @bIdxLevels = 1 
	set @bStatsLevels = 1
end
else if @tMode = 4
begin
	set @bIdxFragLevels = 1
	set @bIdxLevels = 1
	set @bStatsLevels = 1
end
--~~~~~~~~~~~~~~~~~~~~~ END OF CONFIGURABLE SETTINGS ~~~~~~~~~~~~~~~~~~~~~


set @bIsAmazonRDS = case when DB_ID('rdsadmin') is not null and suser_sname(0x01) = 'rdsa' then 1 else 0 end
set @bIsAzureSQLDB = case when SERVERPROPERTY('EngineEdition') = 5 then 1 else 0 end	--SQL Database
set @bIsAzureSQLMI = case when SERVERPROPERTY('EngineEdition') = 8 then 1 else 0 end	--SQL Managed Instance only
select @lastSQLRestart = sqlserver_start_time FROM sys.dm_os_sys_info;

--Version check
declare @sql2 nvarchar(max)
declare @MemNum Nvarchar(max)
declare @CPU varchar (10)
declare @visibleCPU varchar(10)
declare @vSQLMaxMem int
declare	@fullVersion varchar(15)
declare @buildVersion int
declare @warnMsg nvarchar(max)
declare @version tinyint
declare @count smallint
declare	@supportedMsg nvarchar(max)
declare @obsoleteMsg nvarchar(max)
declare @extendedMsg nvarchar(max)
declare @rtmMsg nvarchar(max)
declare @sql3 nvarchar(max)
declare @vmType varchar(15)
declare @versNum varchar(20)
declare @tVersNum tinyint
--time zone
declare @TimeZone nvarchar(50)
declare @sqlZ nvarchar(max)
--server settings
--declare @maxMem int --not really using
declare @minMem int
declare @maxDop sql_variant
declare @maxCrawl sql_variant
declare @costThresh sql_variant
declare @fullTextInstalled bit
declare @buChecksum sql_variant

--Output temp tables
IF OBJECT_ID('tempdb..#ActionableItems') IS NOT NULL
	drop table #ActionableItems
create table #ActionableItems (
	item varchar(max),
	category varchar(3)
)

IF OBJECT_ID('tempdb..#ClearedItems') IS NOT NULL
	drop table #ClearedItems
create table #ClearedItems (
	item varchar(max),
	category varchar(3)
)


--time zone
if @bIsAmazonRDS = 0 and @bIsAzureSQLMI = 0
begin
	set @sqlZ = 'EXEC master.dbo.xp_regread ''HKEY_LOCAL_MACHINE'',
								''SYSTEM\CurrentControlSet\Control\TimeZoneInformation'',
								''TimeZoneKeyName'',
								@TimeZone OUT'
	exec sp_executesql @sqlZ, N'@TimeZone nvarchar(50) OUTPUT', @TimeZone OUTPUT
end
else
	set @TimeZone = NULL								


if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) > 10 -- >= 2012
begin 
	set @sql2 = N'SELECT  @MemNum = cast(physical_memory_kb/1024.0/1024.0 as decimal(15,2))
	FROM    sys.dm_os_sys_info'
	set @sql3 = N'select @vmType = virtual_machine_type_desc from sys.dm_os_sys_info'
end

else if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) = 10 -- 2008 or 2008R2
begin	
	set @sql2 = N'SELECT  @MemNum = cast(physical_memory_in_bytes/1024.0/1024.0/1024.0 as decimal (15,2))	
	FROM    sys.dm_os_sys_info'
	if convert(sysname, SERVERPROPERTY ('productversion')) like '10.5%'
		and CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 2) AS INT) >= 2500	--2008 R2 SP1
		set @sql3 = N'select @vmType = virtual_machine_type_desc from sys.dm_os_sys_info'
	else 
		set @sql3 = N'SELECT  @vmType = NULL FROM sys.dm_os_sys_info'	
end

else
begin		-- < 2008 (not able to test)
	set @sql2 = N'SELECT  @MemNum = NULL FROM sys.dm_os_sys_info'
	set @sql3 = N'SELECT  @vmType = NULL FROM sys.dm_os_sys_info'
end

EXEC sp_executesql @sql2, N'@MemNum NVARCHAR(max) OUTPUT', @MemNum OUTPUT
EXEC sp_executesql @sql3, N'@vmType NVARCHAR(max) OUTPUT', @vmType OUTPUT
 
set @versNum = case
				when convert(sysname, SERVERPROPERTY ('productversion')) like '8.%' then '2000'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '9.%' then '2005'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '10.0%' then '2008'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '10.5%' then '2008 R2'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '11.%' then '2012'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '12.%' then '2014'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '13.%' then '2016'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '14.%' then '2017'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '15.%' then '2019'
				when convert(sysname, SERVERPROPERTY ('productversion')) like '16.%' then '2022'
			end

SELECT  @@SERVERNAME as [@@ServerName],
			SERVERPROPERTY ('INSTANCENAME') as InstanceName,		/* NULL if Default Instance */
			SERVERPROPERTY ('edition') as Edition,
			SERVERPROPERTY ('productversion') as ProdVersion, 
			@versNum as Version,
			SERVERPROPERTY ('productlevel') as ProdLevel,
			SERVERPROPERTY ('productupdatelevel') as UpdateLevel, 
			SERVERPROPERTY ('SERVERNAME') as ServerName,
			SERVERPROPERTY ('MACHINENAME') as MachineName,
			SERVERPROPERTY ('ISCLUSTERED') as IsClustered,
			SERVERPROPERTY ('IsHadrEnabled') as IsHadrEnabled,
			@vmType as VirtMachType,
			SERVERPROPERTY ('collation') as SQLServerCollation,
			cpu_count as [CPU Cnt (LogicalCPUs)], --CORES & HYPERTHREADING INCLUDED IN COUNT
			hyperthread_ratio as [HT Ratio],	--HT INCLUDED IN COUNT
			cpu_count / hyperthread_ratio AS [Physical Sockets], -- aka physical cpu sockets
			@MemNum as PhyMemInGB
	FROM    sys.dm_os_sys_info

select @CPU = i.cpu_count, @visibleCPU = count(s.cpu_id)
from sys.dm_os_sys_info i
cross join sys.dm_os_schedulers s
where s.status = 'VISIBLE ONLINE'
group by i.cpu_count

--SQL vs OS memory check
select @vSQLMaxMem = convert(varchar(max), value_in_use) from sys.configurations where name in ('max server memory (MB)')
--set @vSQLMaxMem = convert(numeric, @vSQLMaxMem)/1024.0

select @tVersNum = CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS tinyint)


print 'Current Date/Time = ' + convert(sysname, getdate()) + ' ' + isnull(@TimeZone, '')
print 'Last SQL Server Restart = ' + convert(sysname, @lastSQLRestart)
print '@@ServerName = ' + @@servername
print 'Server name = ' + (convert(sysname, SERVERPROPERTY('SERVERNAME')))
if @bIsAzureSQLMI = 0
	print 'Machine name = ' + (convert(sysname, SERVERPROPERTY('MACHINENAME')))
if @@servername <> convert(sysname, SERVERPROPERTY('SERVERNAME'))
	--print '   *** @@servername and server name/machine name DO NOT match. As this can create problems down the line, this will need to be fixed and will require a service restart. ***'
	insert into #ActionableItems 
		select '@@servername and server name/machine name DO NOT match. As this can create problems down the line, this will need to be fixed and will require a service restart.
		
', '001'
else
	insert into #ClearedItems 
		select '@@servername vs server name/machine verified.
		
', '001'
	
print 'Instance name = ' + isnull((convert(sysname, SERVERPROPERTY('INSTANCENAME'))), '<default>')
print 'Edition = ' + (convert(sysname, SERVERPROPERTY('edition')))
print 'Version = ' + (convert(sysname, SERVERPROPERTY('productversion')))
if (convert(sysname, SERVERPROPERTY('productupdatelevel'))) is null
	print 'Version Level = ' + @versNum + ' ' + (convert(sysname, SERVERPROPERTY('productlevel')))
else
	print 'Version Level = ' + @versNum + ' ' + (convert(sysname, SERVERPROPERTY('productlevel'))) + ' ' + (convert(sysname, SERVERPROPERTY('productupdatelevel')))
print 'Collation = ' + (convert(sysname, SERVERPROPERTY('collation')))
if @bIsAzureSQLMI = 0
	print 'Is clustered = ' + (convert(sysname, SERVERPROPERTY('isclustered')))
print 'Is AlwaysOn Enabled = ' + isnull((convert(sysname, SERVERPROPERTY('IsHadrEnabled'))), 'N/A')
print 'VM Type = ' + isnull(@vmType, 'N/A')
print 'OS CPUs = ' +  @CPU
print 'Visible CPUs = ' + @visibleCPU
if @CPU <> @visibleCPU
	--print '   *** OS CPU does NOT match CPUs visible by SQL Server ***'
	insert into #ActionableItems
		select 'OS CPU does NOT match CPU visible by SQL Server.
		
', '001'
else
	insert into #ClearedItems
		select 'OS CPU vs SQL Server CPU verified.
		
', '001'
print 'Physical Mem in GB = ' + isnull(@MemNum, 'N/A')
print 'SQL Max Mem in GB = ' +  convert(varchar(max), cast(@vSQLMaxMem/1024.0 as money), 1)

-- max memory caps				 
if SERVERPROPERTY('EditionID') = -1534726760	--Standard edition
begin
	if @versNum = '2008 R2' or @versNum = '2012'
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 64
			insert into #ActionableItems
				select 'Maximum memory utilized per instance in ' + @versNum + ' Standard edition is 64GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Standard edition memory limit verified.
			
', '003'
	end
	else if @tVersNum = 12	--2014 
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 128
			insert into #ActionableItems
				select 'Maximum memory utilized per instance in ' + @versNum + ' Standard edition is 128GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Standard edition memory limit verified.
			
', '003'
	end
	else if @tVersNum >= 13	--2016 and above
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 128
			insert into #ActionableItems
				select 'Maximum memory for the buffer pool per instance in ' + @versNum + ' Standard edition is 128GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Standard edition memory limit verified.
			
', '003'
	end
end
	
if SERVERPROPERTY('EditionID') = 1293598313		--Web edition
begin
	if @versNum = '2008 R2' or @tVersNum = 11 or @tVersNum = 12	-- 2008 R2, 2012, or 2014
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 64
			insert into #ActionableItems
				select 'Maximum memory utilized per instance in ' + @versNum + ' Web edition is 64GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Web edition memory limit verified.
			
', '003'
	end
	else if @tVersNum >= 13		--2016 and above
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 64
			insert into #ActionableItems
				select 'Maximum memory for the buffer pool per instance in '+ @versNum +' Web edition is 64GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Web edition memory limit verified.
			
', '003'
	end
end

if SERVERPROPERTY('EditionID') = -1592396055 or  SERVERPROPERTY('EditionID') = -133711905		--Express editions
begin
	if @versNum = '2008 R2' or @tVersNum = 11 or @tVersNum = 12	-- 2008 R2, 2012, or 2014
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 1
			insert into #ActionableItems
				select 'Maximum memory utilized per instance in ' + @versNum + ' Express edition is 1GB.
			
', '003'
		else
			insert into #ClearedItems
					select 'Express edition memory limit verified.
			
', '003'
	end
	else if @tVersNum >= 13		--2016 and above
	begin
		if cast(@vSQLMaxMem/1024.0 as smallint) >= 1
			insert into #ActionableItems
				select 'Maximum memory for the buffer pool per instance in '+ @versNum +' Web edition is 1GB
			
', '003'
		else
			insert into #ClearedItems
					select 'Web edition memory limit verified.
			
', '003'
	end
end
-- end of max memory caps

if ((convert(float, @MemNum)) < (convert(float, @vSQLMaxMem))/1024.0) and (@vSQLMaxMem <> 2147483647)
	--print '   *** SQL max mem is GREATER THAN the total size of physical memory available to the OS ***'
	insert into #ActionableItems
		select 'SQL Server max memory is GREATER THAN the total size of physical memory available to the OS.
		
', '002'
else
	insert into #ClearedItems
		select 'SQL Server max memory vs total size of physical memory available to the OS verified.
		
', '002'


--=================================================================================================

--Total database count and their states
select count(*) as [# of DBs], state_desc from sys.databases
where source_database_id IS NULL
group by state_desc;


--=================================================================================================
-- Are SharePoint databases installed on this instance?
if (select count(*) from sys.databases where name like ('%SharePoint_Config %') or name like ('%SharePoint_AdminContent_%') or name like ('%WSS_Content%')) > 0
	set @bIsSharePoint = 1



--=================================================================================================

--TOP 3 READ DBS
if @bPDM = 0
begin
	if @bShowSettingsResults = 1
	begin
		SELECT top 3 name AS 'Database Name'
			  ,convert(varchar, cast(SUM(num_of_reads) as money), 1) AS 'Number of Reads', 'TOP 3 READ DBS' as 'TOP 3 READ DBS'
		FROM sys.dm_io_virtual_file_stats(NULL, NULL) I
		  INNER JOIN sys.databases d  
			  ON I.database_id = d.database_id
		where d.source_database_id IS NULL
		GROUP BY name 
		ORDER BY SUM(num_of_reads) DESC
	end
end

--TOP 3 WRITES DBS
if @bPDM = 0
begin
	if @bShowSettingsResults = 1
	begin
		SELECT top 3 name AS 'Database Name'
			  ,convert(varchar, cast(SUM(num_of_writes) as money), 1) AS 'Number of Writes', 'TOP 3 WRITE DBS' as 'TOP 3 WRITE DBS'
		FROM sys.dm_io_virtual_file_stats(NULL, NULL) I
		  INNER JOIN sys.databases d  
			  ON I.database_id = d.database_id
		where d.source_database_id IS NULL
		GROUP BY name 
		ORDER BY SUM(num_of_writes) DESC
	end
end

--TOP I/O
if @bPDM = 0
begin
	if @bShowSettingsResults = 1
	begin
		with     Agg_IO_Stats
		as       (select   DB_NAME(database_id) as database_name,
						   cast (SUM(num_of_reads + num_of_writes) / 2. as decimal (20, 2)) as io_avg
				  from     sys.dm_io_virtual_file_stats (null, null) as DM_IO_Stats
				  group by database_id)
		select   top 3 database_name,
				 convert (varchar, cast(io_avg as money), 1) as io_avg,
				 cast (io_avg / SUM(io_avg) over () * 100 as decimal (5, 2)) as pct,
				 'TOP 3 IO DBS' as 'TOP 3 IO DBS'
		from     Agg_IO_Stats
		order by pct desc
	end
end

--TOP I/O by MBs
if @bPDM = 0
begin
	if @bShowSettingsResults = 1
	begin
		with     Agg_IO_Stats2
		as       (select   DB_NAME(database_id) as database_name,
						   cast (SUM(num_of_bytes_read + num_of_bytes_written) / 1048576. as decimal (20, 2)) as io_in_mb
				  from     sys.dm_io_virtual_file_stats (null, null) as DM_IO_Stats
				  group by database_id)
		select   top 3 database_name,
				 convert(varchar, cast(io_in_mb as money), 1) as io_in_mb,
				 cast (io_in_mb / SUM(io_in_mb) over () * 100 as decimal (5, 2)) as pct,
				 'TOP 3 IO-MBs' as 'TOP 3 IO-MBs'
		from     Agg_IO_Stats2
		order by pct desc
	end
end

--=================================================================================================

--alwaysOn
if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) > 10 -- >= 2012
begin
	if @bShowSettingsResults = 1
	begin
		SELECT db_name([database_id]) as DbName
			  , ag.name	as AG_Name
			  ,r.replica_server_name
			  ,[is_local]
			  ,[synchronization_state_desc]
			  ,[is_commit_participant]
			  ,[synchronization_health_desc]
			  ,[database_state_desc]
			  ,[is_suspended]
			  ,[suspend_reason_desc]
		  FROM [master].[sys].[dm_hadr_database_replica_states] ds
		  inner join sys.availability_groups ag
			on ds.group_id = ag.group_id
		  inner join sys.availability_replicas r
			on ds.replica_id = r.replica_id
		--where [synchronization_health_desc] <> 'Healthy'
			order by DbName, replica_server_name
	end
	
	if (select count(*) from master.sys.dm_hadr_availability_group_states) > 0
	begin	--THIS WAS COMMENTED BEFORE
		if (select count(*) from master.sys.dm_hadr_availability_group_states where [synchronization_health_desc] <> 'Healthy') > 0
			print    '  *** AG sync state is NOT HEALTHY ***'
		--else	--THIS WAS COMMENTED BEFORE
		--	print '       AG sync state verified'	--THIS WAS COMMENTED BEFORE
	end	--THIS WAS COMMENTED BEFORE
	--else	--THIS WAS COMMENTED BEFORE
	--	print 'Always On is not enabled'	--THIS WAS COMMENTED BEFORE
end
--else	--THIS WAS COMMENTED BEFORE
--	print 'Always On is not an available feature for this version of SQL Server'	--THIS WAS COMMENTED BEFORE


--=================================================================================================
--Separate IO Paths
if @bPDM = 0
begin
	declare @dataPath varchar(128)
	declare @logPath varchar(128)
	declare @tempDPath varchar(128)
	declare @tempLPath varchar(128)
	declare @backupPath varchar(128)

	IF OBJECT_ID('tempdb..#defaultFileLocations') IS NOT NULL
	   drop table #defaultFileLocations

	create table #defaultFileLocations 
	(
		FileType varchar(11),
		Location varchar(128)
	)   

	insert into #defaultFileLocations 
		select 'Data', convert(varchar(128), SERVERPROPERTY('InstanceDefaultDataPath'))
	insert into #defaultFileLocations
		select 'Log', convert(varchar(128), SERVERPROPERTY('InstanceDefaultLogPath'))
	insert into #defaultFileLocations
		select 'Backup', convert(varchar(128), SERVERPROPERTY('InstanceDefaultBackupPath'))
	insert into #defaultFileLocations
		select 'Tempdb Data', physical_name from tempdb.sys.database_files where type = 0
	insert into #defaultFileLocations
		select 'Tempdb Log', physical_name from tempdb.sys.database_files where type = 1

	select @dataPath = location from #defaultFileLocations where FileType = 'Data'
	select @logPath = location from #defaultFileLocations where FileType = 'Log'
	select @tempDPath = location from #defaultFileLocations where FileType = 'Tempdb Data'
	select @tempLPath = location from #defaultFileLocations where FileType = 'Tempdb Log'
	select @backupPath = location from #defaultFileLocations where FileType = 'Backup'

	if @bShowSettingsResults = 1
		select 'DEFAULT FILE LOCATIONS' as 'DEFAULT FILE LOCATIONS', * from #defaultFileLocations

	insert into #ActionableItems
		select 'It is best practice to see at least 3 separate IO paths (NOT INCLUDING the C:\ drive) for the data, log, and tempdb files; 4 paths to include backups would be best. Separate physical disks is a performance best practice; using logical IO paths doesn’t provide a performance benefit but does provide an administrative benefit, nonetheless. Here is your configuration:
	data = ' + @dataPath + '
	log = ' + @logPath + '
	tempdb data = ' + @tempDPath + '
	tempdb log = ' + @tempLPath + '
	backup = ' + @backupPath + '
		
', '004'


	/* Cleanup */
	drop table #defaultFileLocations

end


--=================================================================================================
--Start of Version Checks
print '
~~~~~~~~~~~~~ VERSION CHECKS ~~~~~~~~~~~~~'

--version check
set @fullVersion = (convert(sysname, SERVERPROPERTY('productversion')))	--this one is needed, do un-comment
set @supportedMsg = 'SQL version is or surpasses latest SP: ' + @fullVersion
set @obsoleteMsg = '  *** version is also Obsolete & Out of Support ***'
set @extendedMsg = ' *** extended support ends on '
set @rtmMsg = '*** SQL version is RTM and very likely not the latest CU ***'
set @buildVersion = CAST(PARSENAME(@fullVersion, 2) AS INT)

if @fullVersion like '8.%'
begin
	set @version = 80
	if @buildVersion >= 2039  -- 2000 SP4 (released 5/6/05)
		print @supportedMsg + @obsoleteMsg
	else
		print N'  *** SQL version is not the latest SP of 8.0.2039.0. ***' + @obsoleteMsg
end

else if @fullVersion like '9.%'	-- OBSOLOTE 
begin  
	set @version = 90
	if @buildVersion >= 5000  -- 2005 SP4 (released 12/17/10)
		print @supportedMsg + @obsoleteMsg
	else
		print N'  *** SQL version is not the latest SP of 9.00.5000.00 ***' + @obsoleteMsg
end

else if @fullVersion like '10.0%' or @fullVersion like '10.4%' -- OBSOLETE
begin
	set @version = 100
	if @buildVersion >= 6000  --2008 SP4 (released 9/30/14)
		print @supportedMsg + @obsoleteMsg
	else
		print N'  *** SQL version is not the latest SP of 10.0.6000.29 ***' + @obsoleteMsg
end

else if @fullVersion like '10.5%' -- OBSOLETE
begin
	set @version = 100
	if @buildVersion >= 6000  --2008 R2 SP3 (released 9/26/14)
		print @supportedMsg + @obsoleteMsg
	else
		print N'  *** SQL version is not the latest SP of 10.50.6000.34 ***' + @obsoleteMsg
end

else if @fullVersion like '11.%'
begin
	set @version = 110
	if @buildVersion >= 7001 --2012 SP4 (released 10/5/17)
		print @supportedMsg + @extendedMsg + '7/12/2022 ***'
	else
		print N'  *** SQL version is not the latest SP of 11.0.7001.0 ***' + @extendedMsg + '7/12/2022 ***'
end

else if @fullVersion like '12.%'
begin
	set @version = 120
	if @buildVersion >= 6024 --2014 SP3 (released 10/30/18)
		print @supportedMsg + @extendedMsg + '7/9/2024 ***' 
	else
		print N'  *** SQL version is not the latest SP of 12.0.6024.0 ***' + @extendedMsg + '7/9/2024 ***'
end

else if @fullVersion like '13.%'
begin
	set @version = 130
	if @buildVersion >= 6300 --2016 SP3 (released 9/15/21)
		print @supportedMsg + @extendedMsg + '7/14/2026 ***'
	else
		print N'  *** SQL version is not the latest SP of 13.0.6300.2 ***' + @extendedMsg + '7/14/2026 ***'
end

--SPs will no longer be released 2017+  --3/15/20 SGR
else if @fullVersion like '14.%'
begin
	set @version = 140
	if @buildVersion = 1000 --2017 RTM (released 10/2/17)
		print @rtmMsg
	else if @buildVersion > 1000
		print 'SQL version is at least not RTM - verify if latest CU; Rackspace-supported versions are usually at least 3 months old'
end

else if @fullVersion like '15.%'
begin
	set @version = 150
	if @buildVersion = 2000 --2019 RTM (released 11/19/19)
		print @rtmMsg
	else if @buildVersion > 2000
		print 'SQL version is at least not RTM - verify if latest CU; Rackspace-supported versions are usually at least 3 months old'
end

else if @fullVersion like '16.%'
begin
	set @version = 160
	if @buildVersion = 1000 --2022 RTM (released 11/16/22)			
		print @rtmMsg
	else if @buildVersion > 1000			
		print 'SQL version is at least not RTM - verify if latest CU; Rackspace-supported versions are usually at least 3 months old'
end




--determine if the SP/CU poses a risk for the instance
set @warnMsg = NULL
-- up to 2008 SP3 CU7 (10.0.5826.0)
if @fullVersion like '10.0.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 5828
		set @warnMsg = null
	else 
		set @warnMsg = '  *** Memory Leak when using AUTO_UPDATE_STATS_ASYNC - fix is available in 2008 SP3 CU8; however, please consider the latest SP/CU to avoid other issues ***'


-- up to 2008 R2 SP2 CU3 or 2008 R2 SP1 CU9  (10.50.2866.0 or 10.50.4266.0) 
if @fullVersion like '10.50.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 4270
		set @warnMsg = null
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 4000
	begin
		if CAST(PARSENAME(@fullVersion, 2) AS INT) < 4270
			set @warnMsg = '  *** Memory Leak when using AUTO_UPDATE_STATS_ASYNC - fix is available in 2008 R2 SP2 CU4; however, please consider the latest SP/CU to avoid other issues  ***'
	end
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 2868
		set @warnMsg = null
	else --if CAST(PARSENAME(@fullVersion, 2) AS INT) < 2868
		set @warnMsg = '  *** Memory Leak when using AUTO_UPDATE_STATS_ASYNC - fix is available in 2008 R2 SP1 CU10; however, please consider the latest SP/CU to avoid other issues  ***'


-- up to 2012 RTM CU4 (11.0.2383.0), 2012 SP1 (11.0.3000.0 or 11.1.3000.0), up to 2012 SP1 CU10 (11.0.3431), 2012 SP2 CU3 (11.0.5556.0), 2012 SP2 CU4 (11.0.5569.0)
if @fullVersion like '11.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) = 5569 or CAST(PARSENAME(@fullVersion, 2) AS INT) = 5556
		set @warnMsg = '  *** AlwaysOn AG may be reported as NOT SYNCHRONIZING - fix is available in 2012 SP2 CU5; however, please consider the latest SP/CU to avoid other issues  ***'

	else if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 5532 --> 5521
		set @warnMsg = null
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) > 3436
		if CAST(PARSENAME(@fullVersion, 2) AS INT) < 5058
			set @warnMsg = null
		else	-- >= 5058
			set @warnMsg = '  *** Online index rebuilds in parallel can cause corruption - fix is available in 2012 SP2 CU1; however, please consider the latest SP/CU to avoid other issues  ***'
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) < 3436	
		if @fullVersion like '11.0.3000.0' or @fullVersion like '11.1.3000.0'
			set @warnMsg = '  *** msiexec.exe process keeps running after installing SP1 causing 100% CPU - fix is available in 2012 SP1 CU2; however, please consider the latest SP/CU to avoid other issues ***
  *** Online index rebuilds in parallel can cause corruption - fix is available in 2012 SP1 CU11 or 2012 SP2 CU1; however, please consider the latest SP/CU to avoid other issues  ***'
		else if CAST(PARSENAME(@fullVersion, 2) AS INT) < 2384
			set @warnMsg = '  *** Memory Leak when using AUTO_UPDATE_STATS_ASYNC - fix is available in 2012 RTM CU5; however, please consider the latest SP/CU to avoid other issues  ***
  *** Online index rebuilds in parallel can cause corruption - fix is available in 2012 SP1 CU11 or 2012 SP2 CU1; however, please consider the latest SP/CU to avoid other issues  ***'
		else
			set @warnMsg = '  *** Online index rebuilds in parallel can cause corruption - fix is available in 2012 SP1 CU11 or 2012 SP2 CU1; however, please consider the latest SP/CU to avoid other issues  ***'


--up to 2014 RTM CU1 (12.0.2369), 2014 CU5 (12.0.2456.0)
if @fullVersion like '12.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) = 2456
		set @warnMsg = '  *** AlwaysOn AG may be reported as NOT SYNCHRONIZING - fix is available in 2014 RTM CU6; however, please consider the latest SP/CU to avoid other issues  ***'
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) > 2369
		set @warnMsg = null
	else	-- <= 2369
		set @warnMsg = '  *** Online index rebuilds in parallel can cause corruption - fix is available in 2014 RTM CU2; however, please consider the latest SP/CU to avoid other issues  ***'
			

-- up to 2016 SP1 CU9 or 2016 SP2 CU2 (13.0.4474.0 or 13.0.5149.0)
if @fullVersion like '13.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 5153 
		set @warnMsg = null
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 5026	--SP2
	begin
		if CAST(PARSENAME(@fullVersion, 2) AS INT) < 5153
			set @warnMsg = '  *** Backup compression on TDE-enabled dbs can produce corrupt backups - fix is available in 2016 SP2 CU2; however, please consider the latest SP/CU to avoid other issues  ***'	
	end
	else if CAST(PARSENAME(@fullVersion, 2) AS INT) >= 4502
		set @warnMsg = null
	else	--if CAST(PARSENAME(@fullVersion, 2) AS INT) < 4502
		set @warnMsg = '  *** Backup compression on TDE-enabled dbs can produce corrupt backups - fix is available in 2016 SP1 CU9; however, please consider the latest SP/CU to avoid other issues  ***'


-- up to 2017 RTM CU8 (14.0.3029.16)
if @fullVersion like '14.%'
	if CAST(PARSENAME(@fullVersion, 2) AS INT) > 3029
		set @warnMsg = NULL
	else 
		set @warnMsg = '  *** Backup compression on TDE-enabled dbs can produce corrupt backups - fix is available in 2017 RTM CU9; however, please consider the latest CU to avoid other issues  ***'

if @warnMsg is not null
	print @warnMsg


-- check for Meltdown and Spectre vulnerabilities
declare @SpecMeltPatched varchar(max)
declare @VersionLevel varchar(max)

--set @buildVersion = CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 2) AS INT)	--still needed, original code
set @SpecMeltPatched = 'Patch in place to address Spectre and Meltdown side-channel vulnerabilities: ' + @fullVersion
set @VersionLevel = @versNum + ' ' + (convert(sysname, SERVERPROPERTY('productlevel')))

if @fullVersion like '10.5%'	-- 2008 R2
begin
	if @buildVersion >= 6560
		print @SpecMeltPatched
	else  
		print N'  *** Security update needed for 2008 R2 SP3 (KB 4057113) to address Spectre and Meltdown vulnerabilities along with relevant OS patches, if not already done. ***'
end

else if @fullVersion like '10.%'	-- 2008
begin
	if @buildVersion >= 6556
		print @SpecMeltPatched
	else 
		print N'  *** Security update needed for 2008 SP4 (KB 4057114) to address Spectre and Meltdown vulnerabilities along with relevant OS patches, if not already done. ***'
end

else if @fullVersion like '11.%'	-- 2012
begin
	if @buildVersion >= 7462
		print @SpecMeltPatched
	else if @buildVersion > 6615
		print N'  *** Security update needed for 2012 SP4 (KB 4057116) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 6615
		print @SpecMeltPatched
	else if @buildVersion > 6260
		print N'  *** Security update needed for 2012 SP3 CU (KB 4057121) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 6260
		print @SpecMeltPatched
	else
		print N'  *** Security update for 2012 SP3 (KB 4057115) to address spectre and meltdown vulnerabilities along with OS patches, if not already done. ***' 
end

else if @fullVersion like '12.%'	-- 2014
begin
	if @buildVersion >= 5571
		print @SpecMeltPatched
	else if @buildVersion > 5214
		print N'  *** Security update needed for 2014 SP2 CU10 (KB 4057117) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 5214
		print @SpecMeltPatched
	else
		print N'  *** Security update needed for 2014 SP2 GDR (KB 4057120) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
end

else if @fullVersion like '13.%'	-- 2016
begin
	if @buildVersion >= 4466
		print @SpecMeltPatched
	else if @buildVersion > 4210
		print N'  *** Security update needed for 2016 SP1 CU7 (KB 4057119) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 4210
		print @SpecMeltPatched
	else if @buildVersion > 2218
		print N'  *** Security update needed for 2016 SP1 GDR (KB 4057118) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 2218
		print @SpecMeltPatched
	else if @buildVersion > 1745
		print N'  *** Security update needed for 2016 RTM CU (KB 4058559) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 1745
		print @SpecMeltPatched
	else
		print N'  *** Security update needed for 2016 RTM GDR (KB 4058560) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
end

else if @fullVersion like '14.%'	-- 2017
begin
	if @buildVersion >= 3015
		print @SpecMeltPatched
	else if @buildVersion > 2000
		print N'  *** Security update needed for 2017 RTM CU3 (KB 4058562) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
	else if @buildVersion = 2000
		print @SpecMeltPatched
	else
		print N'  *** Security update needed for 2017 GDR (KB 4057122) to address Spectre and Meltdown vulnerabilities along with OS patches, if not already done. ***'
end

--End of Version Checks
print '~~~~~~~~~~ END OF VERSION CHECKS ~~~~~~~~~
'

--=================================================================================================

-- INSERT HEADERS
--if @bPDM = 0
insert into #ActionableItems
	select '
~~~ SYSTEM/CHECKS ~~~

', '000'

insert into #ActionableItems
	select '
~~~ PERFORMANCE ~~~

', '010'

insert into #ActionableItems
	select '
~~~ RECOVERY ~~~

', '050'

insert into #ActionableItems
	select '
~~~ CONFIG ~~~

', '060'

insert into #ActionableItems
	select '
~~~ SECURITY ~~~

', '110'

insert into #ActionableItems
	select '
~~~ INDEXES & STATS ~~~

', '120'

--if @bPDM = 0
/* CLEARED ITEMS DON'T CONTAIN CHECKS */
insert into #ClearedItems
	select '
~~~ SYSTEM/CHECKS ~~~

', '000'

insert into #ClearedItems
	select '
~~~ PERFORMANCE ~~~

', '010'

insert into #ClearedItems
	select '
~~~ RECOVERY ~~~

', '050'

insert into #ClearedItems
	select '
~~~ CONFIG ~~~

', '060'

insert into #ClearedItems
	select '
~~~ SECURITY ~~~

', '110'

insert into #ClearedItems
	select '
~~~ INDEXES & STATS ~~~

', '120'




--=================================================================================================
--print '

--       !!!!! VERIFICATIONS !!!!!
-----------------------------------------'

--config

if @bShowSettingsResults = 1
begin
	SELECT 'CONFIG SETTINGS' as 'CONFIG SETTINGS', configuration_id, name, value, value_in_use, [description] 
	FROM sys.configurations
	where name in ('backup compression default'  -- >= 2k8
				,'clr enabled' 
				,'max degree of parallelism', 'cost threshold for parallelism'
				,'min server memory (MB)', 'max server memory (MB)'
				,'max full-text crawl range'
				,'priority boost'
				,'optimize for ad hoc workloads'  -->2k8
				,'remote admin connections'
				, 'backup checksum default') 
	ORDER BY name OPTION (RECOMPILE);

	select FULLTEXTSERVICEPROPERTY('isfulltextinstalled') as [Is_Full-Text_Installed]

	select 'BACKUP CHECKSUMS' as 'BACKUP CHECKSUMS', database_name, backup_start_date, backup_finish_date, has_backup_checksums
    from msdb.dbo.backupset 
	where has_backup_checksums = 1
	order by backup_start_date desc
end

--select @maxMem = convert(varchar(max), value_in_use) from sys.configurations where name = 'max server memory (MB)'
select @minMem = convert(varchar(max), value_in_use) from sys.configurations where name = 'min server memory (MB)'
select @maxDop = value_in_use from sys.configurations where name = 'max degree of parallelism'
select @maxCrawl = value_in_use from sys.configurations where name = 'max full-text crawl range'
select @costThresh = value_in_use from sys.configurations where name = 'cost threshold for parallelism'
select @fullTextInstalled = FULLTEXTSERVICEPROPERTY('isfulltextinstalled')
select @buChecksum = value_in_use from sys.configurations where name = 'backup checksum default'

if
(select COUNT(*) from sys.configurations where name = 'max server memory (MB)' and value = 2147483647) > 0
	--print '     *** max server memory is NOT SET ***'
	insert into #ActionableItems 
		select 'Max server memory is NOT SET which means SQL Server will try to grab all available memory and not leave enough for the OS and other processes on the server. This setting take effect immediately without a server restart.

', '030'
ELSE
	--print '       max server memory is set to ' + convert(varchar(max), cast(@vSQLMaxMem/1024.00 as money), 1) + ' GB - sufficient?'	
	insert into #ClearedItems 
		select 'Max server memory is set to ' + convert(varchar(max), cast(@vSQLMaxMem/1024.00 as money), 1) + ' GB. Is this sufficient?

', '011'
if
(select COUNT(*) from sys.configurations where name = 'min server memory (MB)' and value = 0) > 0
	--print    '     *** min server memory is NOT SET ***'
	insert into #ActionableItems
		select 'Min server memory is NOT SET. By setting this, it ensures 2 things: SQL Server will be able to allocate data via extents vs pages during the memory ramp to reach the minimum, and once the minimum is reached SQL Server will not relinquish this memory. This setting take effect immediately without a server restart.

', '080'
ELSE
	--print '       min server memory is set to ' + convert(varchar(max), cast(@minMem/1024.00 as money), 1) + ' GB - sufficient?'
	insert into #ClearedItems
		select 'Min server memory is set to ' + convert(varchar(max), cast(@minMem/1024.00 as money), 1) + ' GB. Is this sufficient?

', '080'

if
(select COUNT(*) from sys.configurations where name = 'backup compression default' and value_in_use = 0) > 0
	--print '     *** backup compression is NOT ENABLED ***'
	insert into #ActionableItems
		select 'Backup compression is NOT ENABLED at the instance level. If a user does not specify WITH COMPRESSION when taking a backup, no compression is used. Compression can greatly reduce the size of backups and reduce the time to restore, but it does use some additional CPU resources. Use compression to save disk space but when there is plenty of CPU available. Please note that using backup compression on encrypted databases is not recommended (unless you are at least 2016 SP1 CU9, 2016 SP2 CU2, or 2017 CU9 and also using the MAXTRANSFERSIZE > 64K parameter; if on 2019 CU5, you no longer need the MAXTRANSFERSIZE parameter) .
		
', '080'
ELSE if (select COUNT(*) from sys.configurations where name = 'backup compression default' and value_in_use = 1) > 0
	--print '       backup compression is enabled; verify that backup compression is not being used on ENCRYPTED databases unless at least 2016 SP1 CU9, 2016 SP2 CU2, or 2017 RTM CU9 - best practice'
	insert into #ClearedItems
		select 'Backup compression is enabled; verify that backup compression is not being used on ENCRYPTED databases unless at least 2016 SP1 CU9, 2016 SP2 CU2, or 2017 CU9 and also using the MAXTRANSFERSIZE > 64K parameter; if on 2019 CU5, you no longer need the MAXTRANSFERSIZE parameter.
		
', '080'
else
	--print '       backup compression is not an available feature for this version and/or edition of SQL Server'
	insert into #ClearedItems
		select 'Backup compression is not an available feature for this version and/or edition of SQL Server.
		
', '080'

if @bPDM = 0
begin
	if
	(select COUNT(*) from sys.configurations where name = 'optimize for ad hoc workloads' and value_in_use = 0) > 0
		--print '     *** optimize for ad hoc workloads IS NOT ENABLED ***'
		insert into #ActionableItems
			select 'Optimize for Ad Hoc Workloads is NOT ENABLED. This option is used to improve the efficiency of the plan cache for workloads that contain many single use ad hoc batches. When this option is enabled, the database engine stores a small compiled plan stub in the plan cache when a batch is compiled for the first time, instead of the full compiled plan. This helps to relieve memory pressure by not allowing the plan cache to become filled with compiled plans that are not reused. Setting optimize for ad hoc workloads to true affects only new plans; plans that are already in the plan cache are unaffected.
			
', '030'
	ELSE if (select COUNT(*) from sys.configurations where name = 'optimize for ad hoc workloads' and value_in_use = 1) > 0
		--print '       optimize for ad hoc workloads is enabled - best practice'
		insert into #ClearedItems
			select 'Optimize for Ad Hoc Workloads is enabled.
			
', '030'
	else
		--print '       optimize for ad hoc workloads is not an available feature for this version of SQL Server'
		insert into #ClearedItems
			select 'Optimize for Ad Hoc Workloads is not an available feature for this version of SQL Server.
			
', '030'
end

if
(select COUNT(*) from sys.configurations where name = 'clr enabled' and value_in_use = 1) > 0
	--print '     *** clr IS ENABLED ***'
	insert into #ActionableItems
		select 'CLR is enabled on this instance. If you''re not using it, we should turn off this option as it consumes memory even if unused and is a possible attack vector.
		
', '111'
ELSE
	--print '       clr is not enabled - best practice'
	insert into #ClearedItems
		select 'CLR is not enabled on this instance.
		
', '111'

if
(select COUNT(*) from sys.configurations where name = 'remote admin connections' and value_in_use = 1) > 0
	--print '     *** remote admin connections IS ENABLED ***'
	insert into #ActionableItems
		select 'Remote Admin Connections is enabled allowing remote connections using DAC (DAC is enabled by default but only for local connections). While this option can allow for remote troubleshooting when the server is otherwise unresponsive, please note that there is a vulnerability concern with having this enabled.
		
', '111'
ELSE
	--print '       remote admin connections is not enabled - best practice'
	insert into #ClearedItems
		select 'Remote Admin Connections is not enabled.
		
', '111'

if
(select COUNT(*) from sys.configurations where name = 'priority boost' and value_in_use = 1) > 0
	--print '     *** priority boost IS ENABLED ***'
	insert into #ActionableItems
		select 'Priority Boost is enabled. It is best to keep this deprecated option disabled as it is possible for SQL Server to consume all resources blocking other processes, including authentication. Disabling this option will require a service restart for it to take effect.
		
', '030'
else
	--print '       priority boost is not enabled - best practice'
	insert into #ClearedItems
		select 'Priority Boost is not enabled.
		
', '030'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if @buChecksum = 0
--(select COUNT(*) from sys.configurations where name = 'backup checksum default' and value_in_use = 1) > 0
	if (select COUNT(*) from msdb.dbo.backupset where has_backup_checksums = 1) > 0
		insert into #ActionableItems
			select 'Backup Checksums have been used with your backups but the setting is not enabled by default. Enabling this would make it the default behavior for all backups when not specified and it could help detect corruption more quickly than the integrity checks (unless your integrity checks are done daily, that is) but it could also cause a performance hit.
		
', '052'
	else
		insert into #ActionableItems
			select 'Backup Checksums are not enabled by default and they do not seem to be in use with your current backups. Enabling this would make it the default behavior for all backups (when not specified) and it could help detect corruption more quickly than the integrity checks (unless your integrity checks are done daily, that is) but it could also cause a performance hit. 
		
', '052'
else
	insert into #ClearedItems
		select 'Backup Checksums verified.

', '052'

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if @bPDM = 0
begin
	if
	(select COUNT(*) from sys.configurations where name = 'max degree of parallelism' and value_in_use = 1) > 0
		--print '     *** maxdop IS DISABLED ***'
		if @bIsSharePoint = 1
			insert into #ClearedItems
				select 'Max degree of parallelism (MAXDOP) is disabled which is a recommended best practice for SharePoint databases.
			
', '011'
		else
			insert into #ActionableItems
				select 'Max degree of parallelism (MAXDOP) is disabled (which is only recommended for SharePoint databases). This means parallel plan generation is suppressed. If you have a high number of processes that could benefit from parallelism, this should be adjusted accordingly. The Microsoft recommendation for MAXDOP is to set it to the number of logical processors per core, up to 8 (see MS KB 2806535), and then adjust as necessary.
			
', '011'
	else if
		(select COUNT(*) from sys.configurations where name = 'max degree of parallelism' and value_in_use = 0) > 0
			--print '       maxdop is enabled and set to default of 0'
			if @bIsSharePoint = 0
				insert into #ActionableItems
					select 'Max degree of parallelism (MAXDOP) is enabled and set to default of 0. Setting MAXDOP to 0 allows SQL Server to use all the available processors, up to 64, for parallel plan execution. 0 is NOT the recommended value for most cases.
				
', '011'
			else
				insert into #ActionableItems
					select 'Max degree of parallelism (MAXDOP) is enabled which is not a recommended best practice for SharePoint databases.
			
', '011'
		ELSE
			--print '     *** maxdop is enabled and set to ' + convert(nvarchar(5), @maxDop) + ' - NOT DEFAULT ***'
			if @bIsSharePoint = 0
				insert into #ClearedItems
					select 'Max degree of parallelism (MAXDOP) is enabled and set to ' + convert(nvarchar(5), @maxDop) + ' (this is not the default). If a higher number of processes that could benefit from parallelism are taking longer to execute, this may need to be adjusted. Having it too high or too low can lead to poor performance.

', '011'
			else
				insert into #ActionableItems
					select 'Max degree of parallelism (MAXDOP) is enabled and set to ' + convert(nvarchar(5), @maxDop) + ' (this is not the default). When SharePoint databases reside on an instance, it is a recommended best practice to disable MAXDOP.

', '011'
end
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if @bPDM = 0
begin
	if @maxDop <> 1
		if @bIsSharePoint = 0
		begin
			if
			(select COUNT(*) from sys.configurations where name = 'cost threshold for parallelism' and value_in_use = 5) > 0
				--print '     *** cost threshold for parallelism is set to default of 5 - BUT SHOULD BE ADJUSTED AS THIS IS TOO LOW ***'
				insert into #ActionableItems
					select 'Cost threshold for parallelism is set to 5 which is a default. This value is outdated and too low for today''s CPU speeds. For predominantly OLAP systems, we recommend adjusting to 25; for predominantly OLTP systems, we recommend 50; if a combination, we recommend somewhere in between. This is a dynamic setting and can be changed without a service restart. However, after changing this value, you should test your critical queries with the new value in place to ensure their performance has not degraded.
			
', '011'
			else if @costThresh < 25
				--print '     *** cost threshold for parallelism is set to ' + convert(nvarchar(5), @costThresh) + ' - Too Low? ***'
				insert into #ActionableItems
					select 'Cost threshold for parallelism is set to ' + convert(nvarchar(5), @costThresh) + '. Is this too low?

', '011'
			else
				--print '       cost threshold for parallelism is set to ' + convert(nvarchar(5), @costThresh) + ' - sufficient?'
				insert into #ClearedItems
					select 'Cost threshold for parallelism is set to ' + convert(nvarchar(5), @costThresh) + '. Is this sufficient?
			
', '011'
		end		-- end no sharepoint dbs

		else	-- instance has sharepoint dbs
			insert into #ClearedItems
				select 'Cost threshold for parallelism SHOULD be irrelevant because MAXDOP SHOULD be disabled (but is not) as it is a best practice for instances that host SharePoint databases. If MAXDOP is to remain enabled, then the CTfP value will need to be evaluated.
				
', '011'
	else	-- maxdop is disabled (set to 1)
		insert into #ClearedItems
			select 'Cost threshold for parallelism value is ignored by SQL Server because MAXDOP is disabled. If MAXDOP should be enabled, then the CTfP value will need to be evaluated.

', '011'
		
end
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if @bPDM = 0
begin
	if @fullTextInstalled = 1
	begin
		if
		(select COUNT(*) from sys.configurations where name = 'max full-text crawl range' and value_in_use = 4) > 0
			--print '       max full-text crawl range is set to default of 4'
			insert into #ActionableItems
				select 'Max full-text crawl range is set to default of 4. Ideally, this should be equal to the number of cores on your server, to improve crawl performance.
					
', '030'
		ELSE
			--print '     *** max full-text crawl range is set to ' + convert(nvarchar(3), @maxCrawl) + ' - NOT DEFAULT ***'
			insert into #ActionableItems
				select 'Max full-text crawl range is set to ' + convert(nvarchar(3), @maxCrawl) + '. Ideally, this should be equal to the number of cores on your server, to improve crawl performance.

', '030'
	end
	else 
		--print '       max full-text crawl range option can be ignored -- FULL-TEXT IS NOT INSTALLED'
		insert into #ClearedItems
			select 'Max full-text crawl range option can be ignored as the full-text search feature is not installed.
			
', '030'
end


if @bPDM = 0
begin
	if @fullTextInstalled = 1
	begin
		--where is fulltext enabled?
		SELECT name, is_fulltext_enabled
			FROM sys.databases
			where is_fulltext_enabled = 1

		--FIND WHICH DATABASES HAVE FULL TEXT SEARCH ENABLED AND WHICH HAVE A CATALOG
		declare @FTCount int,
				@FTTtl int;

		set @FTCount = 0
		set @FTTtl = 0

		if object_id('tempdb..#WhereIsFullText') IS NOT NULL
			DROP TABLE #WhereIsFullText
		create table #WhereIsFullText
		(
			dbName sysname,
			ft_cat_id int,
			name sysname,
			path nvarchar(256),
			isDefault bit,
			isAccSensOn bit,
			dataSpaceID int,
			fileID int,
			principalID int,
			isImporting bit
		)

		exec sp_MSforeachdb 'use [?]
		insert into #WhereIsFullText
		select ''?'', *
		from sys.fulltext_catalogs
		'

		select * from #WhereIsFullText
		select @FTCount = count(distinct dbName) from #WhereIsFullText
		select @FTTtl = count(*) from #WhereIsFullText

		if @FTCount > 0
		begin
			insert into #ActionableItems
				select 'Database(s) with Full-Text Catalogs: ' + cast(@FTCount as varchar(5)), '130'
			insert into #ActionableItems
				select '    *** Total number of Full-Text Catalogs: ' + cast(@FTTtl as varchar(5)) + '
     With full-text catalogs in place, you should have a plan in place to maintain your full-text indexes.

', '131'
		end
			else
				insert into #ClearedItems
					select 'Full-Text Catalog verified.
					
', '130'
		--CLEANUP
		drop table #WhereIsFullText

	end
end




--=================================================================================================
--version and settings
if @bShowSettingsResults = 1
begin
	select 'DB SETTINGS' as 'DB SETTINGS', db.[name] as [Database Name],
       db.recovery_model_desc as [Recovery Model],
       db.log_reuse_wait_desc as [Log Reuse Wait Description],
	   db.is_encrypted,
	   db.compatibility_level,
	   [DB Compatibility Level] = 
	   case   db.[compatibility_level] 
	      when 80 then 2000
		  when 90 then 2005
		  when 100 then 2008
		  when 105 then '2008R2' --designation but not an actual value; 105 is not an actual value so this will never come up
		  when 110 then 2012
		  when 120 then 2014
		  when 130 then 2016 	
		  when 140 then 2017
		  when 150 then 2019
		  when 160 then 2022
		  else db.[compatibility_level]	
	   end,
       db.page_verify_option_desc as [Page Verify Option],
	   db.is_encrypted,
       db.is_auto_close_on,
       db.is_auto_shrink_on,
       db.is_auto_create_stats_on,
       db.is_auto_update_stats_on,
       db.is_auto_update_stats_async_on,
       db.is_parameterization_forced,
       db.snapshot_isolation_state_desc,
       db.is_read_committed_snapshot_on
from   sys.databases as db
where source_database_id IS NULL
order by name
option (recompile);
end


----------------------------------------------------------------------------------------------


--settings
if
(select COUNT(*) from sys.databases where is_encrypted = 1 and source_database_id IS NULL) > 0
	begin
		set @count = (select COUNT(*) from sys.databases where is_encrypted = 1 and source_database_id IS NULL)   
		--print N'     *** Encryption is enabled on ' + cast(@count as varchar(5)) + ' database(s); verify that BACKUP COMPRESSION is not being used for these databases unless at least 2016 SP1 CU9, 2016 SP2 CU2, or 2017 RTM CU9 - AND -  ***'
		insert into #ActionableItems
			select 'Encryption is enabled on ' + cast(@count as varchar(5)) + ' database(s); verify that BACKUP COMPRESSION is not being used for these databases unless at least 2016 SP1 CU9, 2016 SP2 CU2, or 2017 RTM CU9 - AND - also using the MAXTRANSFERSIZE > 64K parameter; if on 2019 CU5, you no longer need the MAXTRANSFERSIZE parameter
			
', '081'
	end
else
	--print '       Encryption verified'
	insert into #ClearedItems
		select 'Encryption verified.
		
', '081'

if
(select COUNT(*) from sys.databases where compatibility_level < @version and source_database_id IS NULL) > 0
	begin
		set @count = (select COUNT(*) from sys.databases where compatibility_level < @version and source_database_id IS NULL)
		--print N'     *** Compatibility level does not match instance version on ' + cast(@count as varchar(5)) + ' database(s) ***'
		insert into #ActionableItems
			select 'Compatibility level does not match instance version on ' + cast(@count as varchar(5)) + ' database(s). Please consider changing this to the latest compatibility level if the application code will support it.
			
', '082'
	end
else
	--print '       Compatibility level verified'
	insert into #ClearedItems
		select 'Compatibility level verified.
		
', '082'

if
(select COUNT(*) from sys.databases where page_verify_option_desc not in ('CHECKSUM') and source_database_id IS NULL) > 0
	begin
		set @count = (select COUNT(*) from sys.databases where page_verify_option_desc not in ('CHECKSUM') and source_database_id IS NULL)
		--print N'     *** Page verify option not set to CHECKSUM on ' + cast(@count as varchar(5)) + ' database(s) ***'
		insert into #ActionableItems
			select 'Page verify option not set to CHECKSUM on ' + cast(@count as varchar(5)) + ' database(s). Best practice is to set page verify to CHECKSUM. When CHECKSUM is enabled, the SQL Server database engine calculates a checksum over the contents of the whole page, and stores the value in the page header when a page is written to disk. When the page is read from disk, the checksum is recomputed and compared to the checksum value that is stored in the page header. This helps provide a high level of data-file integrity but does not increase performance.
			
', '082'
	end
else
	--print '       Page verify option verified'
	insert into #ClearedItems
		select 'Page verify option verified.
		
', '082'

if
(select COUNT(*) from sys.databases where is_auto_close_on = 1 and source_database_id IS NULL) > 0
	begin
		set @count = (select COUNT(*) from sys.databases where is_auto_close_on = 1 and source_database_id IS NULL)
		--print N'     *** Auto Close is enabled on ' + cast(@count as varchar(5)) + ' database(s) ***'
		insert into #ActionableItems
			select 'Auto Close is enabled on ' + cast(@count as varchar(5)) + ' database(s). There is minimal cost and overhead associated with shutting down a database but there can be significant overhead involved in spinning a database back up when it is accessed by subsequent users or applications which include loading data back into the buffer and re-compiling queries. Therefore, the system becomes slower when it has to deal with reopening the database.  Best practice is to have this option disabled.
			
', '082'
	end
else
	--print '       Auto Close verified'
	insert into #ClearedItems
		select 'Auto Close verified.
		
', '082'

if
(select COUNT(*) from sys.databases where is_auto_shrink_on = 1 and source_database_id IS NULL) > 0
	begin
		set @count = (select COUNT(*) from sys.databases where is_auto_shrink_on = 1 and source_database_id IS NULL)
		--print N'     *** Auto Shrink is enabled on ' + cast(@count as varchar(5)) + ' database(s) ***'
		insert into #ActionableItems
			select 'Auto Shrink is enabled on ' + cast(@count as varchar(5)) + ' database(s). Auto-shrink is the worst offender as it starts every 30 minutes in the background and tries to shrink databases where the auto-shrink database option is enabled. It is a somewhat unpredictable process in that it only shrinks databases with more than 25 percent free space. Auto-shrink uses lots of resources and causes performance-dropping fragmentation and so is not a recommended practice. 
			
', '082'
	end
else
	--print '       Auto Shrink verified'
	insert into #ClearedItems
		select 'Auto Shrink verified.
		
', '082'

if @bPDM = 0
begin
	if
	(select COUNT(*) from sys.databases where is_auto_update_stats_on = 0 and source_database_id IS NULL) > 0	--auto_udpate_stats is disabled
		begin
			set @count = (select COUNT(*) from sys.databases where is_auto_update_stats_on = 0 and source_database_id IS NULL)
			if @bIsSharePoint = 0
				insert into #ActionableItems
					select 'Auto Update Stats is NOT ENABLED on ' + cast(@count as varchar(5)) + ' database(s). This is enabled by default starting with 2005 so if it’s disabled, it was changed after the install. To avoid waiting for your stats to update and get a new plan, we can also enable the ASYNC option as well which means that instead of halting your query execution until after the stats are updated, you proceed with the outdated plan until after the stats are automatically updated and ready to use; however, please note that this is disabled by default.
				
', '030'
			else
				insert into #ActionableItems
					select 'Auto Update Stats is NOT ENABLED on ' + cast(@count as varchar(5)) + ' database(s). This is enabled by default starting with 2005 so if it’s disabled (and it should only be disabled on SharePoint databases), it was changed after the install. To avoid waiting for your stats to update and get a new plan, we can also enable the ASYNC option as well which means that instead of halting your query execution until after the stats are updated, you proceed with the outdated plan until after the stats are automatically updated and ready to use; however, please note that this is disabled by default. ** Again, this should only be disabled on SharePoint databases. **
				
', '030'
		end
	else	--aus enabled
		insert into #ClearedItems
			select 'Auto Update Stats verified.
			
', '030'
end


--=================================================================================================
--sa disabled?
if @bIsAmazonRDS = 0 and @bIsAzureSQLDB = 0
begin
	if @bShowSettingsResults = 1
	begin
		SELECT name as 'login', is_disabled FROM sys.server_principals where name='sa'
	end
	if (select is_disabled from sys.server_principals where name = 'sa') = 0
		--print N'     *** [sa] account IS ENABLED ***'
		insert into #ActionableItems
			select '[sa] account IS ENABLED. This account is a well-known SQL Server account and it is often targeted by malicious users. Microsoft recommends not using this account in your applications and a best practice is to use a strong password and disable it. Disabling this account will not affect internal processes, meaning databases and/or jobs owned by [sa] will not be affected.
			
', '111'
	else
		--print '       [sa] account is disabled - best practice'
		insert into #ClearedItems
			select '[sa] account is disabled.
			
', '111'
end

--=================================================================================================
--owner of objects
if @bShowSettingsResults = 1 and @bIsAmazonRDS = 0 and @bIsAzureSQLDB = 0
begin
	--databases
	select 'DB OWNERS' as 'DB OWNERS', name as DBOwner, suser_sname(owner_sid) as db_owner, state_desc 
		from sys.databases
		where (suser_sname(owner_sid) is null
		or suser_sname(owner_sid) not in ('sa'))
		and source_database_id IS NULL

	--jobs
	select 'JOB OWNERS' as 'JOB OWNERS', name as JobName, enabled, suser_sname(owner_sid) as JobOwner
		from msdb.dbo.sysjobs
		where SUSER_SNAME(owner_sid) not in ('sa')

	--pkgs/maintenance plans
	if (convert(sysname, SERVERPROPERTY ('productversion'))) like '9%'
		begin
		/*********** 2005 ***********/
		--Maintenance plan/package
			SELECT 'PKG OWNERS' as 'PKG OWNERS', name as PkgName, description, suser_sname(ownersid) as PkgOwner
			FROM msdb.dbo.sysdtspackages90			-- 2005
			WHERE suser_sname(ownersid) not in ('sa')
		
		end
	else
		begin
			/*********** 2008 and above ***********/
		--Maintenace plan/package
			SELECT 'PKG OWNERS' as 'PKG OWNERS', name as PkgName, suser_sname(ownersid) as PkgOwner
			FROM msdb.dbo.sysssispackages	
			WHERE SUSER_SNAME(ownersid) not in ('sa')
		end
end

----------------------------------
if @bIsAmazonRDS = 0 and @bIsAzureSQLDB = 0
begin
	declare @sCount smallint;

	set @sCount = 0
	--databases
	if (select count(*)  
		from sys.databases
		where (suser_sname(owner_sid) is null
		or suser_sname(owner_sid) not in ('sa')) and source_database_id IS NULL and state_desc = 'ONLINE') > 0
	begin
		set @sCount = (select count(*)  
						from sys.databases
						where (suser_sname(owner_sid) is null
						or suser_sname(owner_sid) not in ('sa')) 
						and source_database_id IS NULL
						and state_desc = 'ONLINE')
		--print N'     *** Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' (online) database(s) ***'
		insert into #ActionableItems
			select 'Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' [online] database(s). It is a best practice to have these set to [sa] in case the individual user is no longer active in the domain. This change can be made at any time and does not require any downtime but we do recommend testing after the database owner change, to make sure everything functions as expected.

', '111'
	end
	else
		--print '       DB Owners verified'
		insert into #ClearedItems
			select 'DB Owners verified.
			
', '111'


	set @sCount = 0
	--jobs
	if (select count(*)
		from msdb.dbo.sysjobs
		where SUSER_SNAME(owner_sid) not in ('sa')) > 0
	begin
		set @sCount = (select count(*)
						from msdb.dbo.sysjobs
						where SUSER_SNAME(owner_sid) not in ('sa'))
		--print N'     *** Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' job(s) ***'
		insert into #ActionableItems
			select 'Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' job(s). It is a best practice to have these set to [sa] in case the individual user is no longer active in the domain. If the individual user can no longer authenticate to the domain, the job will fail. This change can be made at any time and does not require any downtime but we do recommend testing after the database owner change, to make sure everything functions as expected.

', '111'
	end
	else
		--print '       Job Owners verified'
		insert into #ClearedItems
			select 'Job Owners verified.

', '111'

	set @sCount = 0
	--pkgs/maintenance plans
	if (convert(sysname, SERVERPROPERTY ('productversion'))) like '9%'
		begin
		-- 2005 Maintenance plan/package
			if (select count(*)
				FROM msdb.dbo.sysdtspackages90			-- 2005
				WHERE suser_sname(ownersid) not in ('sa')) > 0
			begin
				set @sCount = (select count(*)
								FROM msdb.dbo.sysdtspackages90			-- 2005
								WHERE suser_sname(ownersid) not in ('sa'))
				--print N'     *** Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' package(s) ***'
				insert into #ActionableItems
					select 'Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' package(s). It is a best practice to have these set to [sa] in case the individual user is no longer active in the domain. If the individual user can no longer authenticate to the domain, the job will fail. If the maintenance plan is modified, the owner of the job will revert back to the maintenance plan owner, so both the maintenance plan and job’s owner will both have to be changed. This change can be made at any time and does not require any downtime but we do recommend testing after the database owner change, to make sure everything functions as expected.
	
', '111'
 			end
			else
				--print '       Package Owners verified'
				insert into #ClearedItems
					select 'Package Owners verified.
					
', '111'
		end
	else
		begin
		--2008 and above Maintenace plan/package
			if (select count(*)
				FROM msdb.dbo.sysssispackages			-- 2005
				WHERE suser_sname(ownersid) not in ('sa')) > 0
			begin
				set @sCount = (select count(*)
								FROM msdb.dbo.sysssispackages		-- 2005
								WHERE suser_sname(ownersid) not in ('sa'))
				--print N'     *** Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' package(s) ***'
				insert into #ActionableItems
					select 'Owner not set to [sa] on ' + cast(@sCount as varchar(5)) + ' package(s). It is a best practice to have these set to [sa] in case the individual user is no longer active in the domain. If the individual user can no longer authenticate to the domain, the job will fail. If the maintenance plan is modified, the owner of the job will revert back to the maintenance plan owner, so both the maintenance plan and job’s owner will both have to be changed. This change can be made at any time and does not require any downtime but we do recommend testing after the database owner change, to make sure everything functions as expected.
					
', '111'
 			end
			else
				--print '       Package Owners verified'
				insert into #ClearedItems
					select 'Package Owners verified.
					
', '111'
		end
end

--=================================================================================================
--growth rates
declare @countFil smallint;
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	SELECT 'DB GROWTH' as 'DB GROWTH', DB_NAME([database_id])AS [Database Name], /*[file_id],*/ 
	--name, 
	physical_name,
					  'Type'=     case TYPE_DESC          
					  when 'ROWS' then 'Data'                         
					  when 'log' then 'Log'  
					  ELSE type_desc                         
					  end,                          
	cast(cast(size as float) / 128 as decimal(18, 2)) AS [Total *INITIAL* MB],                           
					  'Growth Increment'= CASE                            
					  WHEN IS_PERCENT_GROWTH = 1 THEN STR(GROWTH) + '  %'                            
					  ELSE STR((GROWTH * 8) / 1024)+ ' mb'                        
					  end, 
	--growth, max_size, 
	"MaxSize" = 
		case 
			when max_size = 0 or growth = 0 then '*** No growth allowed ***' 
			when max_size = -1 and growth > 0 then 'File will grow until disk full' --unlimited
			when max_size = 268435456 and growth > 0 then 'File will grow to max size of 2TB' --might as well be unlimited
			when max_size > 0 and growth > 0 then '*** File growth limited to fixed size ***' 
			end ,          
	state_desc As [StateDesc]
	FROM sys.master_files
	ORDER BY DB_NAME([database_id]) OPTION (RECOMPILE);
end

if @bPDM = 0
begin
	if 
	(select count(*) from sys.master_files where (max_size = 0 or growth = 0)) > 0
		begin
			set @countFil = (select COUNT(*) from sys.master_files where (max_size = 0 or growth = 0))
			--print N'     *** No growth allowed on ' + cast(@countFil as varchar(5)) + ' file(s) ***'
			insert into #ActionableItems
				select 'No growth allowed on ' + cast(@countFil as varchar(5)) + ' file(s). Once the file(s) grow to that size, it will cease to function until the file size is adjusted or the file is shrunk. In most cases, it is better to avoid limiting the file size and instead place the file on a disk or array with plenty of room to grow, should it need it.
				
', '080'
		end

	else if 
	(select count(*) from sys.master_files where (max_size > 0 and max_size < 268435456 and growth > 0)) > 0
		begin
			set @countFil = (select COUNT(*) from sys.master_files where (max_size > 0 and max_size < 268435456 and growth > 0))
			--print N'     *** File growth limited to fixed size on ' + cast(@countFil as varchar(5)) + ' file(s) ***'
			insert into #ActionableItems
				select 'File growth limited to fixed size on ' + cast(@countFil as varchar(5)) + ' file(s). Once a file grows to its fixed size, it will cease to function until the max file size is adjusted or the file is shrunk. In most cases, it is better to avoid setting a max file size and instead place the file on a disk or array with plenty of room to grow, should it need it.
				
', '080'
		end

	else
		--print '       Max file size verified'
		insert into #ClearedItems
			select 'Max file size verified.
			
', '080'

	if
	(select COUNT(*) from sys.master_files where (GROWTH * 8 / 1024 = 1 and is_percent_growth = 0)) > 0
		begin
			set @countFil = (select COUNT(*) from sys.master_files where (GROWTH * 8 / 1024 = 1 and is_percent_growth = 0))
			--print N'     *** Growth increment set to 1MB on ' + cast(@countFil as varchar(5)) + ' file(s) ***'
			insert into #ActionableItems
				select 'Growth increment set to 1MB on ' + cast(@countFil as varchar(5)) + ' file(s). This tends to make the database very fragmented, and will cause large inserts to take longer as the database must grow several times. A rate such as 10% for small databases and 250MBs for large databases (10GBs or more) would be better. This can be changed at any time.
				
', '030'
		end
	else
		--print '       File growth verified'
		insert into #ClearedItems
			select 'File growth verified.
			
', '030'
end
	 
--=================================================================================================
-- tempdb
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	SELECT 'TEMPDB SETTINGS' as 'TEMPDB SETTINGS', DB_NAME([database_id])AS [Database Name], /*[file_id], name,*/ physical_name,
					  'Type'=     case TYPE_DESC          
					  when 'ROWS' then 'Data'                         
					  when 'log' then 'Log'                           
					  end,                          
	cast(cast(size as float) / 128 as decimal(18, 2)) AS [Total *INITIAL* MB],   
	--is_percent_growth, growth,                        
					  'Growth'= CASE                            
					  WHEN IS_PERCENT_GROWTH = 1 THEN STR(GROWTH) + '  %'                            
					  ELSE STR((GROWTH * 8) / 1024)+ ' mb'                        
					  end,
	state_desc As [StateDesc]
	FROM sys.master_files
	WHERE database_id = 2
end

if @bPDM = 0
begin
	if
	(select COUNT(*) from sys.master_files where database_id = 2) = 2
			--print '     *** Only 1 tempdb data file set ***'
			insert into #ActionableItems
				select 'Only 1 tempdb data file set. We recommend multiple data files to prevent contention on system objects in tempdb. The ratio can be anywhere from 0.25 to 1 x the number of cores, depending on your tempdb utilization.
				
', '011'
	else
	begin
		set @countFil = (select COUNT(*) from sys.master_files where database_id = 2 and type = 0)
		--print '       tempdb DATA file count = ' + cast(@countFil as varchar(5))
		insert into #ClearedItems
			select 'Tempdb data file count = ' + cast(@countFil as varchar(5)) + '. Is this sufficient?
			
', '011'
	end

	--initial size of multiple files not the same && growth rate of multiple files not the same
	declare @firstdbname sysname, @firstType tinyint, @firstInitSize int, @firstGrowth int;
	declare @dbname sysname, @type tinyint, @initialSize int, @growthIncr int;
	declare @fail1 bit, @fail2 bit;

	declare @tdbSizeCursor as CURSOR;

	set @fail1 = 0;
	set @fail2 = 0;

	set @tdbSizeCursor = cursor for
	select DB_NAME([database_id])AS [Database Name], type, size, growth
		from sys.master_files
		where database_id = 2;

	open @tdbSizeCursor;

	fetch next from @tdbSizeCursor into 
		@firstdbname, @firstType, @firstInitSize, @firstGrowth

	while @@fetch_status = 0
	begin
		fetch next from @tdbSizeCursor into
			@dbname, @type, @initialSize, @growthIncr
			if @fail1 = 0
			begin
				if @firstInitSize <> @initialSize and @firstType = @type
				begin
					--print '     *** Tempdb initial file size not the same ***'
					insert into #ActionableItems
						select 'Tempdb initial file sizes are not the same. They need to have the initial file sizes. The system has a thread per core so it can actually spread out operations to the data files. This does not require a SQL Server service stop and start to take effect.
						
', '011'
					set @fail1 = 1
				end
			end
			if @fail2 = 0
			begin
				if @firstGrowth <> @growthIncr and @firstType = @type
				begin 
					--print '     *** Tempdb growth increments not the same ***'
					insert into #ActionableItems
						select 'Tempdb growth increments are not the same. They need to have the same growth increments. The system has a thread per core so it can actually spread out operations to the data files. This does not require a SQL Server service stop and start to take effect.
		
', '011'
					set @fail2 = 1
				end
			end
	end
	if @fail1 = 0
		--print '       Tempdb initial file size verified'
		insert into #ClearedItems
			select 'Tempdb initial file sizes verified.
			
', '011'
	if @fail2 = 0
		--print '       Tempdb growth increments verified'
		insert into #ClearedItems
			select 'Tempdb growth increments verified.
			
', '011'

	close @tdbSizeCursor
	deallocate @tdbSizeCursor
end

--=================================================================================================

--trace flag checks
--SELECT 'Startup Trace Flags' as [Startup Trace Flags]
if @bShowSettingsResults = 1
begin
SELECT
	'STARTUP TRACE FLAGS' as 'STARTUP TRACE FLAGS',
	DSR.registry_key,
	DSR.value_name,
	DSR.value_data
FROM sys.dm_server_registry AS DSR
WHERE 
	DSR.registry_key LIKE N'%MSSQLServer\Parameters'
	and convert(varchar(7),DSR.value_data) like  '-T%';
end


IF OBJECT_ID('tempdb..#FlagStatus') IS NOT NULL
   drop table #FlagStatus
CREATE TABLE #FlagStatus (
        TrFlag           VARCHAR(5)
        , Stat             bit
		, Glob		bit
		, Sess		bit
    )   

INSERT INTO #FlagStatus EXECUTE ('DBCC TRACESTATUS(1117, -1) with no_infomsgs')
INSERT INTO #FlagStatus EXECUTE ('DBCC TRACESTATUS(1118, -1) with no_infomsgs')
INSERT INTO #FlagStatus EXECUTE ('DBCC TRACESTATUS(3226, -1) with no_infomsgs')
INSERT INTO #FlagStatus EXECUTE ('DBCC TRACESTATUS(2371, -1) with no_infomsgs')

-- 1117/1118 (tempdb) check not necessary if SQL Server version is >= 2016
if @bPDM = 0
begin
	if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) >= 13 -- >= 2016
		--print '       Trace flag 1117 & 1118 check not necessary due to version of SQL Server'
		insert into #ClearedItems
			select 'Trace flag 1117 & 1118 check not necessary due to version of SQL Server.
			
', '011'
	else
	begin
		if (select count(*) from #FlagStatus where TrFlag = '1117' and Glob = 1) > 0
		begin
			--print '       Trace flag 1117 is enabled globally'
			insert into #ClearedItems
				select 'Trace flag 1117 is enabled globally.
				
', '011'
		end
		else
		begin
			--print '     *** Trace flag 1117 is NOT ENABLED globally ***'
			insert into #ActionableItems
				select 'Trace flag 1117 is NOT ENABLED globally. When enabled and a data file needs to grow, all data files within a filegroup grow at the same time so they all remain the same size, reducing allocation contention points. This is for any database and not just tempdb but also please note that this is the default behavior starting with SQL Server 2016. Adding this trace flag to your startup parameters will require a service restart to take effect.
				
', '011'
		end

		if (select count(*) from #FlagStatus where TrFlag = '1118' and Glob = 1) > 0
		begin
			--print '       Trace flag 1118 is enabled globally'
			insert into #ClearedItems
				select 'Trace flag 1118 is enabled globally.
				
', '011'
		end
		else
		begin
			--print '     *** Trace flag 1118 is NOT ENABLED globally ***'
			insert into #ActionableItems
				select 'Trace flag 1118 is NOT ENABLED globally. When enabled and doing allocations for user tables, this will allocate full extents. It reduces contention of mixes extent allocations. Adding this trace flag to your startup parameters will require a service restart to take effect.
				
', '011'
		end
	end
end

-- 3226 (successful backup logging) check for all versions
if (select count(*) from #FlagStatus where TrFlag = '3226' and Glob = 1) > 0
begin
	--print '       Trace flag 3226 is enabled globally'
	insert into #ClearedItems
		select 'Trace flag 3226 is enabled globally.
		
', '090'
end
else
begin
	--print '     *** Trace flag 3226 is NOT ENABLED globally ***'
	insert into #ActionableItems
		select 'Trace flag 3226 is NOT ENABLED globally. By default, every successful backup operation adds an entry in the SQL Server error log and in the system event log. If you create very frequent log backups, these "success messages" accumulate quickly, resulting in huge error logs in which finding other messages is problematic. With this trace flag, you can suppress these log entries. Enabling this trace flag is useful if you are running frequent log backups and if none of your scripts depend on those entries. Adding this trace flag to your startup parameters will require a service restart to take effect.
		
', '090'
end

-- 2371 (update stats threshold) check only for < 2016 and compatibility level < 130
if @bPDM = 0
begin
	if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) >= 13 -- >= 2016
	begin
		if
		(select COUNT(*) from sys.databases where compatibility_level < 130 and source_database_id IS NULL) = 0
			begin
				--print '       Trace flag 2371 check not necessary due to version of SQL Server and compatibility level of databases'
				insert into #ClearedItems
					select 'Trace flag 2371 check not necessary due to version of SQL Server and compatibility level of databases.
					
', '011'
			end
	
		else
		begin
			if (select count(*) from #FlagStatus where TrFlag = '2371' and Glob = 1) > 0
			begin
				--print '       Trace flag 2371 is enabled globally - at least one database is not at compatibiltiy level 130'
				insert into #ClearedItems
					select 'Trace flag 2371 is enabled globally - at least one database is not at compatibiltiy level 130.
					
', '011'
			end
			else
			begin
				--print '     *** Trace flag 2371 is NOT ENABLED globally - at least one database is below compatibility level 130 ***'
				insert into #ActionableItems
					select 'Trace flag 2371 is NOT ENABLED globally and at least one database is below compatibility level 130. Enabling this trace flag changes the fixed update statistics threshold to a linear update stats threshold. This is a server level flag and cannot be enabled/disabled for only some databases (unless the compatibility level < 130). It should only be enabled is you are on SAP systems -OR- you rely on a nightly job to update statistics because current automatic update is not triggered frequently enough. The upside to this flag is more efficient execution plans where outdated stats were an issue before. The downside is the execution plan would need to be re-compiled as opposed to using a cached plan. This could potentially be countered by enabling the AUTO-UPDATE-STATS-ASYNC option. This is the default behavior starting with SQL Server 2016 (with compatibility level 130+).
					
', '011'
			end
		end
	end
	else	-- < 2016
	begin
		if (select count(*) from #FlagStatus where TrFlag = '2371' and Glob = 1) > 0
		begin
			--print '       Trace flag 2371 is enabled globally'
			insert into #ClearedItems
				select 'Trace flag 2371 is enabled globally.
				
', '011'
		end
		else
		begin
			--print '     *** Trace flag 2371 is NOT ENABLED globally ***'
			insert into #ActionableItems
				select 'Trace flag 2371 is NOT ENABLED globally. Enabling this trace flag changes the fixed update statistics threshold to a linear update stats threshold. This is a server level flag and cannot be enabled/disabled for only some databases (unless the compatibility level < 130). It should only be enabled is you are on SAP systems -OR- you rely on a nightly job to update statistics because current automatic update is not triggered frequently enough. The upside to this flag is more efficient exeuction plans where outdated stats were an issue before. The downside is the execution plan would need to be re-compiled as opposed to using a cached plan. This ould potentially be countered by enabling the AUTO-UPDATE-STATS-ASYNC option. This is the default behavior starting with SQL Server 2016 (with compatibility level 130+).
				
', '011'
		end
	end
end

if @bShowSettingsResults = 1
begin
	select 'TRACE FLAG CHECK' as 'TRACE FLAG CHECK',
			TrFlag as [TraceFlag],
			Stat as [Status],
			Glob as [Global],
			Sess as [Session]
	 from #FlagStatus;
 end
drop table #FlagStatus;

--=================================================================================================
--lock pages in memory & instant file initialization checks
if @bPDM = 0
begin
	if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) > 13	-- >2016	--1/27/19 SGR
	or 
	   (CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) = 13 and		-- =2016 	--1/27/19 SGR
		CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 2) AS INT) >= 4001)		-- >=SP1
	begin
		IF OBJECT_ID('tempdb..#v2k16sp1stage1') IS NOT NULL
			drop table #v2k16sp1stage1
		create table #v2k16sp1stage1 (
			svcName sysname,
			insta_file_init_enabled char(1)
		);
		IF OBJECT_ID('tempdb..#v2k16sp1stage2') IS NOT NULL
			drop table #v2k16sp1stage2
		create table #v2k16sp1stage2 (
			sql_mem_mod tinyint,
			sql_mem_mod_desc sysname
		);
		
		insert into #v2k16sp1stage1
		exec sp_executesql N'insert into #v2k16sp1stage1
		select servicename, instant_file_initialization_enabled
				FROM sys.dm_server_services 
				where instant_file_initialization_enabled is not null;'

		insert into #v2k16sp1stage2
		exec sp_executesql N'select sql_memory_model, sql_memory_model_desc
				FROM sys.dm_os_sys_info;'
		
		if @bShowSettingsResults = 1	
		begin
			SELECT 'INSTANT FILE INITIALIZATION' as 'INSTANT FILE INITIALIZATION', svcName, insta_file_init_enabled
				FROM #v2k16sp1stage1;

			SELECT 'LOCK PAGES IN MEM' as 'LOCK PAGES IN MEM', sql_mem_mod, sql_mem_mod_desc
				FROM #v2k16sp1stage2;
		end
		if (select insta_file_init_enabled from #v2k16sp1stage1 where svcName like 'SQL Server (%') = 'Y'	--SGR 1/20/2019
			--print '       Instant file initialization is enabled for the service account'
			insert into #ClearedItems
				select 'Instant file initialization is enabled for the service account. 
				
', '090'
		else
			--print '     *** Instant file initialization is NOT ENABLED for the service account ***'
			insert into #ActionableItems
				select 'Instant file initialization is NOT ENABLED for the service account. Instant file initialization requires the Perform Volume Maintenance Right. We recommend enabling this policy on the SQL Server service account on your server. Please note that instant file initialization will not happen on databases where TDE is in use. This change does require a service stop and start to take effect.
				
', '090'

		if (SELECT sql_mem_mod from #v2k16sp1stage2) = 2
			--print '       Lock pages in memory is enabled for the service account'
			insert into #ClearedItems
				select 'Lock pages in memory is enabled for the service account.
				
', '040'
		else
			--print '     *** Lock pages in memory is NOT ENABLED for the service account ***'
			insert into #ActionableItems
				select 'Lock pages in memory is NOT ENABLED for the service account. Locking pages in memory may boost performance when paging to disk is expected. We recommend enabling this policy on the SQL Server service account on your server. This change does require a service stop and start to take effect.
				
', '040'
		
		drop table #v2k16sp1stage1;
		drop table #v2k16sp1stage2;
	end
	else if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) = 11	  -- =2012	--1/20/19 SGR
		and CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 2) AS INT) >= 7001	-- >=SP4
	begin
		IF OBJECT_ID('tempdb..#v2k12sp4stage1') IS NOT NULL
			drop table #v2k12sp4stage1
		create table #v2k12sp4stage1 (
			svcName sysname,
			insta_file_init_enabled char(1)
		);
		IF OBJECT_ID('tempdb..#v2k12sp4stage2') IS NOT NULL
			drop table #v2k12sp4stage2
		create table #v2k12sp4stage2 (
			sql_mem_mod tinyint,
			sql_mem_mod_desc sysname
		);
		
		insert into #v2k12sp4stage1
		exec sp_executesql N'insert into #v2k12sp4stage1
		select servicename, instant_file_initialization_enabled
				FROM sys.dm_server_services 
				where instant_file_initialization_enabled is not null;'

		insert into #v2k12sp4stage2
		exec sp_executesql N'select sql_memory_model, sql_memory_model_desc
				FROM sys.dm_os_sys_info;'
		
		if @bShowSettingsResults = 1	
		begin
			SELECT 'INSTANT FILE INITIALIZATION' as 'INSTANT FILE INITIALIZATION', svcName, insta_file_init_enabled
				FROM #v2k12sp4stage1;

			SELECT 'LOCK PAGES IN MEM' as 'LOCK PAGES IN MEM', sql_mem_mod, sql_mem_mod_desc
				FROM #v2k12sp4stage2;
		end
		if (select insta_file_init_enabled from #v2k12sp4stage1 where svcName like 'SQL Server (%') = 'Y'	--SGR 1/20/2019
			--print '       Instant file initialization is enabled for the service account'
			insert into #ClearedItems
				select 'Instant file initialization is enabled for the service account.
				
', '090'
		else
			--print '     *** Instant file initialization is NOT ENABLED for the service account ***'
			insert into #ActionableItems
				select 'Instant file initialization is NOT ENABLED for the service account. Instant file initialization requires the Perform Volume Maintenance Right. We recommend enabling this policy on the SQL Server service account on your server. Please note that instant file initialization will not happen on databases where TDE is in use. This change does require a service stop and start to take effect.
				
', '090'

		if (SELECT sql_mem_mod from #v2k12sp4stage2) = 2
			--print '       Lock pages in memory is enabled for the service account'
			insert into #ClearedItems
				select 'Lock pages in memory is enabled for the service account.
				
', '040'
		else
			--print '     *** Lock pages in memory is NOT ENABLED for the service account ***'
			insert into #ActionableItems
				select 'Lock pages in memory is NOT ENABLED for the service account. Locking pages in memory may boost performance when paging to disk is expected. We recommend enabling this policy on the SQL Server service account on your server. This change does require a service stop and start to take effect.
				
', '040'
		
		drop table #v2k12sp4stage1;
		drop table #v2k12sp4stage2;
	end
	else
	begin
		--print '       Lock pages in mem not verifiable via DMVs - NEED TO CHECK OS'
		insert into #ActionableItems																-- DEBUG **************************
			select 'Lock pages in mem not verifiable with DMVs - NEED TO CHECK OS.
			
', '040'
		--print '       Instant file initialization not verifiable via DMVs - NEED TO CHECK OS'	
		insert into #ActionableItems																-- DEBUG **************************
			select 'Instant file initialization not verifiable with DMVs - NEED TO CHECK OS.
			
', '090'
	end
end


--=================================================================================================
--msdb too large
if @bIsAzureSQLDB = 0
begin
	if (select COUNT(*) from msdb.sys.database_files where (size*8)/1024 > 8192) > 0  -- 8192 is 8GB
		begin
			--print N'     *** msdb has at least one file greater than 8GB ***'
			insert into #ActionableItems
				select 'Msdb has at least one file greater than 8GB. This is usually because the backup and job history files aren’t being deleted on a timely basis. Large msdb databases can make the system respond slower, and take longer to recover on startup. I recommend saving only 30 days’ worth of history, and implementing a weekly job to ensure it keeps only thirty days going forward.
				
', '011'
		end
	else
		begin
			--print '       msdb size verified'
			insert into #ClearedItems
				select 'msdb size verified.
				
', '011'
		end
end

--=================================================================================================
--Log file check
/* Log file is 3/4 the size of the data file */
declare @sLFCount smallint
set @sLFCount = 0;
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	SELECT 'LARGER-THAN-DATA LOG FILES' as 'LARGER-THAN-DATA LOG FILES',
		DB_NAME(f1.database_id) as dbName,
		convert(varchar, convert(money, sum(f1.size/128)), 1) as 'sum of data_MB',
		convert(varchar, convert(money, sum(f2.size/128)), 1) as 'sum of logs_MB'
	FROM sys.master_files f1
		JOIN sys.master_files as f2
		on f1.database_id = f2.database_id
		and f1.data_space_id = 1
		and f1.type = 0
		and f2.data_space_id = 0
	GROUP BY DB_NAME(f1.database_id)
	HAVING (sum(f1.size/128.0)*0.75) < sum(f2.size/128.0)	-- check if log file is 3/4 the size of the data file
		and sum(f1.size/128.0) > 1024	-- data file is larger than 1GB
end 

if @bPDM = 0
begin
	if (select count(*) from sys.master_files f1
			JOIN sys.master_files as f2
			on f1.database_id = f2.database_id
			and f1.data_space_id = 1
			and f1.type = 0
			and f2.data_space_id = 0
			--group by DB_NAME(f1.database_id)
			having (sum(f1.size/128.0)*0.75) < sum(f2.size/128.0)
			and sum(f1.size/128.0) > 1024) > 0
		begin
			set @sLFCount = (select count(*) from sys.master_files f1 
												JOIN sys.master_files as f2
												on f1.database_id = f2.database_id
												and f1.data_space_id = 1
												and f1.type = 0
												and f2.data_space_id = 0
											--group by DB_NAME(f1.database_id)
											having (sum(f1.size/128.0)*0.75) < sum(f2.size/128.0)
												and sum(f1.size/128.0) > 1024) 
			--print cast (@sCount as varchar(5)) + N'     *** Log file at least 3/4 the size of their data file on ' +  cast(@sCount as varchar(5)) + ' databases ***'	
			insert into #ActionableItems
				select 'Log file at least 3/4 the size of their data file on ' +  cast(@sCount as varchar(5)) + ' databases. Depending on the transactional activity, this may be expected and/or needed. If not, this could be because log backups were not in place with full recovery or .......*******
				
', '051'
		end
		else
			begin
				--print '       Log file sizes verified'
				insert into #ClearedItems
					select 'Log file sizes verified.
					
', '051'
			end
end




--=================================================================================================
--VLF count
if @bPDM = 0
begin
	--declare @sCount smallint;
	DECLARE @MajorVersion smallint ; 
	SELECT  @MajorVersion = CAST(substring(CAST(SERVERPROPERTY('productversion') AS VARCHAR), 0, 
							Charindex('.', CAST(SERVERPROPERTY('productversion') AS VARCHAR))) AS smallint); 

	if @bIsAmazonRDS = 0
	begin
		if @MajorVersion > 10
		begin
			IF OBJECT_ID('tempdb..#vstage') IS NOT NULL
				drop table #vstage
			create Table #vstage (
				RecoveryUnitID int
			  , FileID      int
			  , FileSize    bigint
			  , StartOffset bigint
			  , FSeqNo      bigint
			  , [Status]    bigint
			  , Parity      bigint
			  , CreateLSN   numeric(38)
			)
			IF OBJECT_ID('tempdb..#vresults') IS NOT NULL
				drop table #vresults
			Create Table #vresults(
				Database_Name   sysname
			  , VLF_count       int 
			);
 
			Exec sp_MSforeachdb N'Use [?]; 
						Insert Into #vstage 
						Exec sp_executesql N''DBCC LogInfo([?]) with no_infomsgs''; 
 
						Insert Into #vresults 
						Select DB_Name(), Count(*) 
						From #vstage; 
 
						Truncate Table #vstage;'
			if @bShowSettingsResults = 1
			begin
				Select 'VLF COUNTS' as 'VLF COUNTS', * 
				From #vresults
				Order By VLF_count Desc;
			end

			if (select count(*) from #vresults where VLF_count > 1000) > 0
				begin
					set @sCount = (select count(*) from #vresults where VLF_count > 1000) 
					--print N'     *** VLF count is greater than 1000 on ' + cast (@sCount as varchar(5)) + ' log file(s) ***'	
					insert into #ActionableItems
						select 'VLF count is greater than 1,000 on ' + cast (@sCount as varchar(5)) + ' log file(s). This can occur after excessive auto-growth and should be addressed. Fixing this does not require a restart, but it should occur during a less busy time.

', '051'
				end
			else
				begin
					--print '       VLF count verified'
					insert into #ClearedItems
						select 'VLF count verified.

', '051'
				end

			Drop Table #vstage;
			Drop Table #vresults;
		end
		else
		begin
			IF OBJECT_ID('tempdb..#vstage2') IS NOT NULL
				drop table #vstage2
			create Table #vstage2(
				FileID      int
			  , FileSize    bigint
			  , StartOffset bigint
			  , FSeqNo      bigint
			  , [Status]    bigint
			  , Parity      bigint
			  , CreateLSN   numeric(38)
			)
			IF OBJECT_ID('tempdb..#vresults2') IS NOT NULL
				drop table #vresults2
			Create Table #vresults2(
				Database_Name   sysname
			  , VLF_count       int 
			);
 
			Exec sp_msforeachdb N'Use [?]; 
						Insert Into #vstage2 
						Exec sp_executesql N''DBCC LogInfo([?]) with no_infomsgs''; 
 
						Insert Into #vresults2
						Select DB_Name(), Count(*) 
						From #vstage2; 
 
						Truncate Table #vstage2;'
			if @bShowSettingsResults = 1
			begin
				Select 'VLF COUNTS' as 'VLF COUNTS', * 
				From #vresults2
				Order By VLF_count Desc;
			end

			if (select count(*) from #vresults2 where VLF_count > 1000) > 0
				begin
					set @sCount = (select count(*) from #vresults2 where VLF_count > 1000) 
					--print N'     *** VLF count is greater than 1000 on ' + cast (@sCount as varchar(5)) + ' log file(s) ***'	
					insert into #ActionableItems
						select 'VLF count is greater than 1,000 on ' + cast (@sCount as varchar(5)) + ' log file(s). This can occur after excessive auto-growth and should be addressed. Fixing this does not require a restart, but it should occur during a less busy time.

'	, 5
				end
			else
				begin
					--print '       VLF count verified'
					insert into #ClearedItems
						select 'VLF count verified.

', '051'
				end

			Drop Table #vstage2;
			Drop Table #vresults2;
		end
	end
end

--=================================================================================================
------------------- RECOVERY MODELS AND LOG BACKUPS
if @bShowSettingsResults = 1
begin
	--RECOVERY MODELS
	select 'RECOVERY MODELS' as 'RECOVERY MODELS', name as [DB Name], recovery_model_desc as [RecoveryModel], state_desc
	from sys.databases
	where source_database_id IS NULL
	order by name	
end

--this might need an if statement
set @sCount = (select count(*) from sys.databases where recovery_model_desc = 'full' and source_database_id IS NULL and state_desc = 'ONLINE') 
insert into #ClearedItems				--DEBUG NOT SURE *****************************************************************************
	select 'Database(s) [online] using the FULL recovery model: ' + cast (@sCount as varchar(5)) + '.

', '051'

--======================================================


--FULL RECOVERY WITH NO LOG BACKUPS
if @bIsAzureSQLDB = 0
begin
	if @bShowSettingsResults = 1
	begin
		select 'NO LOG BACKUPS' as 'NO LOG BACKUPS', d.name 
		FROM master.sys.databases d
		LEFT OUTER JOIN msdb.dbo.backupset b 
			ON d.name = b.database_name 
				AND b.type = 'L'		-- L ==> Tlog
		WHERE (d.database_id NOT IN (2, 3) and d.recovery_model IN (1, 2))
		and (b.recovery_model is null or b.backup_finish_date is null) and d.source_database_id IS NULL and d.state_desc = 'ONLINE'
	end
	if
	(select COUNT(*)
	FROM master.sys.databases d
	LEFT OUTER JOIN msdb.dbo.backupset b 
		ON d.name = b.database_name 
			AND b.type = 'L'		-- L ==> Tlog
	WHERE (d.database_id NOT IN (2, 3) and d.recovery_model IN (1, 2))
	and (b.recovery_model is null or b.backup_finish_date is null) and d.source_database_id IS NULL and d.state_desc = 'ONLINE') > 0
		begin 
			set @sCount = (select COUNT(*)
							FROM master.sys.databases d
							LEFT OUTER JOIN msdb.dbo.backupset b 
								ON d.name = b.database_name 
									AND b.type = 'L'		-- L ==> Tlog
							WHERE (d.database_id NOT IN (2, 3) and d.recovery_model IN (1, 2))
							and (b.recovery_model is null or b.backup_finish_date is null) and d.source_database_id IS NULL and d.state_desc = 'ONLINE')
			--print N'     *** No LOG backup taken on ' + cast(@sCount as varchar(5)) + ' database(s) ***'
			insert into #ActionableItems
				select 'No LOG backup taken on ' + cast(@sCount as varchar(5)) + ' [online] database(s). Backup jobs will need to be in place; if they are, ensure the databases are not deliberately being ignored. If they are, the recovery model should be reconsidered. Once one of those options are actioned, their log files may need to be shrunk.

', '051'
		end
	else
	begin
		insert into #ClearedItems
			select 'Log backups verified.

', '051'
	end
end


--======================================================
--FULL RECOVERY WITH LOG BACKUPS OLDER THAN 1 DAY
IF OBJECT_ID('tempdb..#old') IS NOT NULL
	drop table #old
create table #old (
	name sysname,
	last_log_bu datetime,
	age_day int
);

insert into #old
	SELECT  d.name
		,max(b.backup_finish_date) AS last_TLOG_backup_finish_date
		, datediff(d, max(b.backup_finish_date), getdate()) as days
	FROM master.sys.databases d
	LEFT OUTER JOIN msdb.dbo.backupset b 
		ON d.name = b.database_name 
			AND b.type = 'L'		-- L ==> Tlog
	WHERE (d.database_id NOT IN (2, 3)		-- 2 = tempdb; 3 = model
		and d.recovery_model IN (1, 2))		-- 1 = Full; 2 = Bulk-logged; 3 = Simple
		and d.source_database_id IS NULL	-- null means not a database snapshot
		and d.state_desc = 'ONLINE'			-- only check dbs that are online
	GROUP BY d.name
	having datediff(d, max(b.backup_finish_date), getdate()) > 1

if @bShowSettingsResults = 1
begin
	--LOG BACKUPS
	select 'LOG BACKUPS' as 'LOG BACKUPS', * from #old
end

set @sCount = 0;
if (select count (*) from #old) > 0
	begin 
		set @sCount = (select count(*) from #old)
		--print N'     *** Most recent LOG backup on ' + cast(@sCount as varchar(5)) + ' database(s) is older than 1 day ***'
		insert into #ActionableItems
			select 'Most recent LOG backup on ' + cast(@sCount as varchar(5)) + ' database(s) is older than 1 day. If backup jobs are already in place, consider checking the job history. Log backups will fail until a full backup is taken. If the log backup hasn''t been taken for a bit, their log files may need to be shrunk.

', '051'
	end
drop table #old


--======================================================
--NO FULL BACKUPS
if @bShowSettingsResults = 1
begin
	--SELECT 'FULL BACKUPS'
	SELECT 'FULL BACKUPS' as 'FULL BACKUPS', d.name
		,MAX(b.backup_finish_date) AS Last_full_bu
	FROM master.sys.databases d
	LEFT OUTER JOIN msdb.dbo.backupset b 
		ON d.name = b.database_name 
			AND b.type = 'D'	
	WHERE (d.database_id NOT IN (2, 3))-- and  b.backup_finish_date is null)
	and d.source_database_id IS NULL	-- null means not a database snapshot
	and d.state_desc = 'ONLINE'		-- only check dbs that are online
	group by d.name
end

set @sCount = 0;
if (SELECT count(*)
FROM master.sys.databases d
LEFT OUTER JOIN msdb.dbo.backupset b 
	ON d.name = b.database_name 
		AND b.type = 'D'	
WHERE d.database_id NOT IN (2, 3) and b.backup_finish_date is null and d.source_database_id IS NULL and d.state_desc = 'ONLINE') > 0
	begin
		set @sCount = (SELECT count(*)
						FROM master.sys.databases d
						LEFT OUTER JOIN msdb.dbo.backupset b 
							ON d.name = b.database_name 
								AND b.type = 'D'	
						WHERE d.database_id NOT IN (2, 3) and b.backup_finish_date is null and d.source_database_id IS NULL and d.state_desc = 'ONLINE')
		--print N'     *** No FULL backup taken on ' + cast(@sCount as varchar(5)) + ' database(s) ***'
		insert into #ActionableItems
			select 'No FULL backup taken on ' + cast(@sCount as varchar(5)) + ' database(s). It’s important to have a backup strategy for both your system databases and your user databases, so that you can ensure recoverability in the event of a disaster. Backup jobs will need to be in place; if they are, ensure your databases are not deliberately being ignored.

', '051'
	end


--=================================================================================================
--AUTOGROWTH EVENTS

--THIS ONLY WORKS IF THE DEFAULT TRACE FILE DOES NOT HAVE A FUNKY FILE NAME!!!
--find autogrowth events
--SELECT 'AUTOGROWTH EVENTS'
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	IF OBJECT_ID('tempdb..#DefTrace') IS NOT NULL
		drop table #DefTrace

	create table #DefTrace 
	(
		[AUTOGROWTH EVENTS] varchar(17),
		StartTime datetime,
		EndTime datetime,
		EventName nvarchar(128),
		DbName sysname,
		FileName sysname,
		Growth_MB float,
		Duration_MS	int
	);
	declare @grwthCt int;
	declare @dataGrowth int;
	declare @logGrowth int;
	declare @oldestDTrecord datetime;

	DECLARE @filename NVARCHAR(1000);
	DECLARE @bc INT;
	DECLARE @ec INT;
	DECLARE @bfn VARCHAR(1000);
	DECLARE @efn VARCHAR(10);

	-- Get the name of the current default trace
	SELECT @filename = CAST(value AS NVARCHAR(1000))
	FROM ::fn_trace_getinfo(DEFAULT)
	WHERE traceid = 1 AND property = 2;

	-- rip apart file name into pieces
	SET @filename = REVERSE(@filename);
	SET @bc = CHARINDEX('.',@filename);
	SET @ec = CHARINDEX('_',@filename)+1;
	SET @efn = REVERSE(SUBSTRING(@filename,1,@bc));
	SET @bfn = REVERSE(SUBSTRING(@filename,@ec,LEN(@filename)));

	-- set filename without rollover number
	SET @filename = @bfn + @efn	
	
	select  @oldestDTrecord = min(ftg.StartTime)
	FROM ::fn_trace_gettable(@filename, DEFAULT) AS ftg
	INNER JOIN sys.trace_events AS te ON ftg.EventClass = te.trace_event_id  

	SELECT 'DEFAULT TRACE' as 'DEFAULT TRACE', 
	  min(ftg.StartTime) as MinDate, 
	  max(ftg.starttime) as MaxDate,
	  @filename as DefaultTrace_Filename
	FROM ::fn_trace_gettable(@filename, DEFAULT) AS ftg
	INNER JOIN sys.trace_events AS te ON ftg.EventClass = te.trace_event_id  

	-- process all trace files
	insert into #DefTrace
		SELECT 'AUTOGROWTH EVENTS' as 'AUTOGROWTH EVENTS',
		  ftg.StartTime
		,ftg.EndTime
		,te.name AS EventName
		,DB_NAME(ftg.databaseid) AS DatabaseName  
		,ftg.Filename
		,(ftg.IntegerData*8)/1024.0 AS GrowthMB
		,(ftg.duration/1000)AS DurMS
		FROM ::fn_trace_gettable(@filename, DEFAULT) AS ftg
		INNER JOIN sys.trace_events AS te 
			ON ftg.EventClass = te.trace_event_id  
		WHERE 1=1
		   and (
				ftg.EventClass = 92	-- Date File Auto-grow
				or ftg.EventClass = 93  -- Log File Auto-grow
				)
		ORDER BY ftg.StartTime

	select * from #DefTrace

	select @grwthCt = count(*) from #DefTrace
	select @dataGrowth = count(*) from #DefTrace where EventName = 'Data File Auto Grow'
	select @logGrowth = count(*) from #DefTrace where EventName = 'Log File Auto Grow'
	
	if @grwthCt > 0
		insert into	#ActionableItems
			select 'Auto-growth events exists in your default trace. ' + cast(@dataGrowth as varchar(5)) + ' data file(s) and ' +  cast(@logGrowth as varchar(5)) + ' log file(s) have auto-grown since ' + cast(@oldestDTrecord as varchar(25)) + '. You may want to consider sizing your files appropriately, to avoid excessive auto-growth. 
			
', '082'
	else
		insert into #ClearedItems
			select 'Autogrowth events verified.
			
', '082'

	--CLEANUP
	drop table #DefTrace

end


--=================================================================================================
--integrity
------------------- INTEGRITY
if @bIsAmazonRDS = 0
begin
	IF OBJECT_ID('tempdb..#tempDBCC') IS NOT NULL
		drop table #tempDBCC
	CREATE TABLE #tempDBCC (          
		   ParentObject     VARCHAR(255)
		   , [Object]       VARCHAR(255)
		   , Field          VARCHAR(255)
		   , [Value]        VARCHAR(255)   
	   )   
	IF OBJECT_ID('tempdb..#DBCCResults') IS NOT NULL
		drop table #DBCCResults
	CREATE TABLE #DBCCResults (
			ServerName           VARCHAR(255)
			, DBName             VARCHAR(255)
			, LastCleanDBCCDate  DATETIME   
		)   
    
	EXEC master.dbo.sp_MSforeachdb       
			   @command1 = 'USE [?] INSERT INTO #tempDBCC EXECUTE (''DBCC DBINFO WITH TABLERESULTS, no_infomsgs'')'
			   , @command2 = 'INSERT INTO #DBCCResults SELECT @@SERVERNAME, ''?'', Value FROM #tempDBCC WHERE Field = ''dbi_dbccLastKnownGood'''
			   , @command3 = 'TRUNCATE TABLE #tempDBCC'   
   
	   --Delete duplicates due to a bug in SQL Server 2008
   
		;WITH DBCC_CTE AS
	   (
		   SELECT ROW_NUMBER() OVER (PARTITION BY ServerName, DBName, LastCleanDBCCDate ORDER BY LastCleanDBCCDate) RowID
		   FROM #DBCCResults
	   )
	   DELETE FROM DBCC_CTE WHERE RowID > 1;

	   if @bShowSettingsResults = 1
	   begin   
		   --SELECT 'INTEGRITY CHECK'
		   SELECT 'INTEGRITY CHECK' as 'INTEGRITY CHECK',       
			   ServerName       
			   , DBName   
			   , CASE LastCleanDBCCDate			
				   WHEN '1900-01-01 00:00:00.000' THEN 'Never ran DBCC CHECKDB' 
				   ELSE CAST(LastCleanDBCCDate AS VARCHAR) END AS LastCleanDBCCDate    
		   FROM #DBCCResults 
		   WHERE DBName <> 'tempdb'  
		   ORDER BY 3
	   end

	   set @sCount = 0;
	   if (SELECT count(*)
			FROM #DBCCResults
			WHERE LastCleanDBCCDate = '1900-01-01 00:00:00.000' and DBName <> 'tempdb') > 0 
			begin
				set @sCount = (SELECT count(*)
								FROM #DBCCResults
								WHERE LastCleanDBCCDate = '1900-01-01 00:00:00.000' and DBName <> 'tempdb')
				--print ''
				--print N'     *** No integrity check has been run on ' + cast(@sCount as varchar(5)) + ' database(s) ***'
				insert into #ActionableItems
					select 'No integrity check has been run on ' + cast(@sCount as varchar(5)) + ' database(s). We recommend checking the integrity of your databases at least once a week, preferably daily (this really depends on how much data you would be okay with losing in case of corruption) and before taking database backups (before the backup helps ensure that a valid restore can be done).

', '051'
			end
			else
				--print N'       Integrity Checks verified'
				insert into #ClearedItems
					select 'Integrity Checks verified.

', '051'

		IF OBJECT_ID('tempdb..#oldDBCC') IS NOT NULL
			drop table #oldDBCC
		create table #oldDBCC (
			dbNam sysname,
			LastCleanDBCC datetime,
			ageDay int
			)

		insert into #oldDBCC
			SELECT  DBName       
					, LastCleanDBCCDate
					, datediff(d, LastCleanDBCCDate, getdate()) 
			   FROM #DBCCResults
			   where LastCleanDBCCDate > '1900-01-01' and DBName <> 'tempdb'
			   group by DBName, LastCleanDBCCDate
			   having datediff(d, LastCleanDBCCDate, getdate()) > 7

		if @bShowSettingsResults = 1
		begin
			--select 'INTEGRITY CHECK - AGED'
			select 'INTEGRITY CHECK - AGED' as 'INTEGRITY CHECK - AGED', dbNam AS DBName, LastCleanDBCC as LastCleanDBCCDate, ageDay as DaysOld
				from #oldDBCC
		end

		set @sCount = 0;
		if (select count (*) from #oldDBCC) > 0
			begin 
				set @sCount = (select count(*) from #oldDBCC)
				--print N'     *** Most recent integrity check on ' + cast(@sCount as varchar(5)) + ' database(s) is older than 1 week ***'
				insert into #ActionableItems
					select 'Most recent integrity check on ' + cast(@sCount as varchar(5)) + ' database(s) is older than 1 week. We recommend checking the integrity of your databases at least once a week, preferably daily (this really depends on how much data you would be okay with losing in case of corruption) and before taking database backups (before the backup helps ensure that a valid restore can be done).

', '051'
			end
			else
			--	print N'       AGED Integrity Checks verified'
			insert into #ClearedItems
					select 'Aged Integrity Checks verified.

', '051'
		drop table #oldDBCC

	 
	   DROP TABLE #tempDBCC, #DBCCResults;

end


--======================================================
--QUERY STORE CHECK

declare @sQDScnt smallint
declare @sQDSstateCnt smallint
set @sQDScnt = 0
set @sQDSstateCnt = 0


--check version of sql to make sure QDS is even possible
if CAST(PARSENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), 4) AS INT) >= 13 -- >= 2016
begin
	declare @QSCheck table 
		(dbName varchar(256), 
		CurrentStorage_MB INT, 
		MaxStorage_MB INT, 
		interval_len_min int,
		stale_query_threshold_days int,	
		desired_state_desc varchar(60),
		actual_state_desc varchar(60)
		)
	insert into @QSCheck
	EXEC master..sp_MSforeachdb 'USE [?]
	IF ''?'' <> ''master'' AND ''?'' <> ''tempdb''
	BEGIN
		select d.name, q.current_storage_size_mb, q.max_storage_size_mb, q.interval_length_minutes, q.stale_query_threshold_days, q.desired_state_desc, q.actual_state_desc
		from sys.databases d
		inner join sys.database_query_store_options q
		on d.name = ''?''
		where d.is_query_store_on = 1
	END
	'
	
	if @bShowSettingsResults = 1
		select 'QUERY STORE' as 'QUERY STORE', * from @QSCheck
	select @sQDScnt = count(*) from @QSCheck

	--check for those whose desired state doesn't match the actual state
	select @sQDSstateCnt = count(*) from @QSCheck where desired_state_desc <> actual_state_desc
	
	if @sQDScnt > 0
	begin
		if @sQDSstateCnt > 0
			--print '	 *** Query Store - desired state DOESN''T MATCH actual state on ' + cast(@sQDSstateCnt as varchar(5)) + ' database(s) ***'
			insert into #ActionableItems
				select 'Query Store enabled but desired state DOES NOT match actual state on ' + cast(@sQDSstateCnt as varchar(5)) + ' database(s). If this was not intentional/expected, consider checking the query store properties and modifying the operational mode.

', '082'
		else
			--print '       Query Store enabled; desired/actual states match'
			insert into #ClearedItems
				select 'Query Store enabled; desired/actual states match.

', '082'
	end
	else
		--print '       Query Store not enabled on any databases'
		insert into #ClearedItems
			select 'Query Store not enabled on any databases.

', '082'

end
else
	--print '       Query Store is not an available feature for this version of SQL Server'
	insert into #ClearedItems
		select 'Query Store is not an available feature for this version of SQL Server.

', '082'





--=================================================================================================
--SOPHOS CHECK
if @bShowSettingsResults = 1 and @bPDM = 0
begin 
	Select 'SOPHOS CHECK' as 'SOPHOS CHECK', * from sys.dm_os_loaded_modules 
	where (name like '%SOPHOS%.DLL' or name like  '%SWI_IFSLSP_64.dll' or name like '%SWI_IFSLSP.dll')
end

if @bPDM = 0
begin
	if
	(select COUNT(*) from sys.dm_os_loaded_modules 
	where (name like '%SOPHOS%.DLL' or name like  '%SWI_IFSLSP_64.dll' or name like '%SWI_IFSLSP.dll')) > 0
		begin
			--print '     *** Sophos DLLs are loaded into SQL Server Memory Process ***'
			insert into #ActionableItems
				select 'Sophos DLLs are loaded into SQL Server Memory Process. This can affect the performance of the server. https://support.microsoft.com/en-us/kb/2033238. Policy changes to ensure they are longer loading into the SQL Server memory process will require a reboot.

', '111'
		end
	ELSE
		begin
			--print '       Sophos DLLs verified - currently not loaded into SQL Server Memory Process'
			insert into #ClearedItems
				select 'Sophos DLLs verified; currently not loaded into SQL Server Memory Process.

', '111'
		end
end

/*
•	To check exclusions -- default exclusions already in place. Engine, SSRS, SSAS and FT not excluded so extra exclusions will be needed if they use more than the engine.
	o	Bring up Sophos Endpoint Security and Control > Configure anti-virus and HIPS > On-demand extensions and exclusions > Exclusions tab
•	To check SQL Server Process Memory Space
	o	 Select * from sys.dm_os_loaded_modules where (name like '%SOPHOS_DETOURED.DLL' or name like  '%SOPHOS_DETOURED_x64.DLL' or name like  '%SWI_IFSLSP_64.dll')
	       CHANGED TO Select 'SOPHOS CHECK', * from sys.dm_os_loaded_modules where (name like '%SOPHOS%.DLL' or name like  '%SWI_IFSLSP_64.dll')   -- SGR 1/18/2020
	o	Any records returned indicates that Sophos DLLs are loaded inside SQL Server Memory Process.

	https://one.rackspace.com/display/IAE/Domain+Controller%2C+MS+SQL+and+SharePoint+Server+Considerations+for+Sophos+Endpoint

*/



--=================================================================================================
--WAIT STATS
if @bPDM = 0
begin
	SET NOCOUNT ON;
	/* Top 10 Wait Stats Issues Reporter*/
	/* Created by Rudy Panigas http://www.sqlservercentral.com/scripts/94439/ */
	/* https://blogs.msdn.microsoft.com/sql_server_team/troubleshooting-high-hadr_sync_commit-wait-type-with-always-on-availability-groups/ */
	/* https://blogs.msdn.microsoft.com/sql_server_team/sql-server-20162017-availability-group-secondary-replica-redo-model-and-performance/ */

	--CURSOR VARIABLE
	declare @wait varchar(50)
	declare @percentage decimal(4,2)
	declare @waitcomment varchar(max)
	set @sCount = 1

	/* Create Temporary Tables for processing */
	IF OBJECT_ID('tempdb..#results') IS NOT NULL
		drop table #results
	create table #results
	( wait_type nvarchar(60)
	, waiting_tasks_count bigint
	, WaitS decimal(18,2)
	, ResourceS decimal(18,2)
	, SignalS decimal(18,2)
	, Percentage decimal(4,2)
	, RowNum int
	, Comment varchar(max)
	)

	/* Insert Wait State information into temporary tables */

	insert #results
	( wait_type
	, waiting_tasks_count
	, WaitS
	, ResourceS
	, SignalS
	, Percentage
	, RowNum
	)

	(SELECT top 10
		   wait_type,
		   waiting_tasks_count AS WaitCount,
		   wait_time_ms / 1000.0 AS Wait_S,
		   (wait_time_ms - signal_wait_time_ms) / 1000.0 AS Resource_S,
		   signal_wait_time_ms / 1000.0 AS Signal_S,
			100.0 * wait_time_ms / SUM (wait_time_ms) OVER() AS Percentage,
			ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS RowNum

		FROM   sys.dm_os_wait_stats

		--where wait_type					--> NOT SURE IF KEEPING THE INCLUSIVE OR EXCLUSIVE CHECK
		--not in ('BROKER_EVENTHANDLER',
		--		'BROKER_RECEIVE_WAITFOR',
		--		'BROKER_TASK_STOP',
		--		'BROKER_TO_FLUSH',
		--		'BROKER_TRANSMITTER',
		--		'CHECKPOINT_QUEUE',
		--		'CHKPT',
		--		'CLR_AUTO_EVENT',
		--		'CLR_MANUAL_EVENT',
		--		'CLR_SEMAPHORE',
		--		'DIRTY_PAGE_POLL',
		--		'DISPATCHER_QUEUE_SEMAPHORE',
		--		'EXECSYNC',
		--		'FSAGENT',
		--		'FT_IFTS_SCHEDULER_IDLE_WAIT',
		--		'FT_IFTSHC_MUTEX',
		--		'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
		--		'KSOURCE_WAKEUP',
		--		'LAZYWRITER_SLEEP',
		--		'LOGMGR_QUEUE',
		--		'MEMORY_ALLOCATION_EXT',
		--		'ONDEMAND_TASK_QUEUE',
		--		'PARALLEL_REDO_DRAIN_WORKER',
		--		'PARALLEL_REDO_LOG_CACHE',
		--		'PARALLEL_REDO_TRAN_LIST',
		--		'PARALLEL_REDO_WORKER_SYNC',
		--		'PARALLEL_REDO_WORKER_WAIT_WORK',
		--		'PREEMPTIVE_OS_FLUSHFILEBUFFERS',
		--		'PREEMPTIVE_XE_GETTARGETSTATE',
		--		'PVS_PREALLOCATE',
		--		'PWAIT_ALL_COMPONENTS_INITIALIZED',
		--		'PWAIT_DIRECTLOGCONSUMER_GETNEXT',
		--		'PWAIT_EXTENSIBILITY_CLEANUP_TASK',
		--		'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
		--		'QDS_ASYNC_QUEUE',
		--		'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP',
		--		'QDS_SHUTDOWN_QUEUE',
		--		'REDO_THREAD_PENDING_WORK',
		--		'REQUEST_FOR_DEADLOCK_SEARCH',
		--		'RESOURCE_QUEUE',
		--		'SERVER_IDLE_CHECK',
		--		'SLEEP_BPOOL_FLUSH',
		--		'SLEEP_DBSTARTUP',
		--		'SLEEP_DCOMSTARTUP',
		--		'SLEEP_MASTERDBREADY',
		--		'SLEEP_MASTERMDREADY',
		--		'SLEEP_MASTERUPGRADED',
		--		'SLEEP_MSDBSTARTUP',
		--		'SLEEP_SYSTEMTASK',
		--		'SLEEP_TASK',
		--		'SLEEP_TEMPDBSTARTUP',
		--		'SNI_HTTP_ACCEPT',
		--		'SOS_WORK_DISPATCHER',
		--		'SP_SERVER_DIAGNOSTICS_SLEEP',
		--		'SQLTRACE_BUFFER_FLUSH',
		--		'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
		--		'SQLTRACE_WAIT_ENTRIES',
		--		'VDI_CLIENT_OTHER',
		--		'WAIT_FOR_RESULTS',
		--		'WAITFOR',
		--		'WAITFOR_TASKSHUTDOWN',
		--		'WAIT_XTP_RECOVERY',
		--		'WAIT_XTP_HOST_WAIT',
		--		'WAIT_XTP_OFFLINE_CKPT_NEW_LOG',
		--		'WAIT_XTP_CKPT_CLOSE',
		--		'XE_DISPATCHER_JOIN',
		--		'XE_DISPATCHER_WAIT',
		--		'XE_TIMER_EVENT')
		
		--better to filter out unnecessary waits than to only allow certain ones ??? This was before the output file became the report. Now since the report will have details
		where
		/* Parallelism */
		wait_type = 'CXPACKET' 
		OR wait_type = 'CXCONSUMER'		--NEW

		/* CPU Issues */
		OR wait_type = 'SOS_SCHEDULER_YIELD'
		OR wait_type = 'THREADPOOL'		--NEW

		/* Network Issues */
		OR wait_type = 'ASYNC_NETWORK_IO' 
		
		/* Locking Issues */
		OR wait_type = 'LCK_M_BU' 
		OR wait_type = 'LCK_M_IS' 
		OR wait_type = 'LCK_M_IU' 
		OR wait_type = 'LCK_M_IX' 
		OR wait_type = 'LCK_M_RIn_NL'
		OR wait_type = 'LCK_M_RIn_S'
		OR wait_type = 'LCK_M_RIn_U'
		OR wait_type = 'LCK_M_RIn_X'
		OR wait_type = 'LCK_M_RS_S' 
		OR wait_type = 'LCK_M_RS_U' 
		OR wait_type = 'LCK_M_RX_S' 
		OR wait_type = 'LCK_M_RX_U' 
		OR wait_type = 'LCK_M_RX_X' 
		OR wait_type = 'LCK_M_S'    
		OR wait_type = 'LCK_M_SCH_M' 
		OR wait_type = 'LCK_M_SCH_S' 
		OR wait_type = 'LCK_M_SIU'   
		OR wait_type = 'LCK_M_SIX'   
		OR wait_type = 'LCK_M_U'     
		OR wait_type = 'LCK_M_UIX'   
		OR wait_type = 'LCK_M_X'     
		OR wait_type = 'LATCH_DT'    
		OR wait_type = 'LATCH_EX'    
		OR wait_type = 'LATCH_KP'    
		OR wait_type = 'LATCH_SH'    
		OR wait_type = 'LATCH_UP'    
		
		/* Memory Issues */
		OR wait_type = 'RESOURCE_SEMAPHORE' 
		OR wait_type = 'RESOURCE_SEMAPHORE_MUTEX'
		OR wait_type = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
		OR wait_type = 'RESOURCE_SEMAPHORE_SMALL_QUERY' 

		/* Disk or Disk Subsystem Issues */
		OR wait_type = 'PAGEIOLATCH_DT' 
		OR wait_type = 'PAGEIOLATCH_EX' 
		OR wait_type = 'PAGEIOLATCH_KP' 
		OR wait_type = 'PAGEIOLATCH_SH' 
		OR wait_type = 'PAGEIOLATCH_UP' 
		OR wait_type = 'PAGELATCH_DT' 
		OR wait_type = 'PAGELATCH_EX' 
		OR wait_type = 'PAGELATCH_KP' 
		OR wait_type = 'PAGELATCH_SH' 
		OR wait_type = 'PAGELATCH_UP' 
		OR wait_type = 'LOGBUFFER'
		OR wait_type = 'ASYNC_IO_COMPLETION'
		OR wait_type = 'IO_COMPLETION' 
		OR wait_type = 'WRITELOG'

		/* Always On Issues */
		or wait_type = 'HADR_SYNC_COMMIT'
		or wait_type = 'PARALLEL_REDO_FLOW_CONTROL'	-- internal use only
		or wait_type = 'PARALLEL_REDO_TRAN_TURN'	-- internal use only
		or wait_type = 'DIRTY_PAGE_TABLE_LOCK'		-- internal use only
		or wait_type = 'DPT_ENTRY_LOCK'				-- internal use only

		/* Other */
		or wait_type = 'OLEDB'
		or wait_type = 'BACKUP'
		or wait_type = 'BACKUPBUFFER'
		or wait_type = 'BACKUPIO'
		or wait_type = 'BACKUPTHREAD'
		or wait_type = 'MSQLXP'
		or wait_type = 'PREEMPTIVE_OS_%'
		or wait_type = 'CMEMTHREAD'
		or wait_type = 'LOGBUFFER'
		or wait_type = 'SNI_CRITICAL_SECTION'
		or wait_type = 'SQLTRACE_FILE_BUFFER'
		or wait_type = 'SQLTRACE_FILE_WRITE_IO_COMPLETION'
		)

		UPDATE [dbo].[#results] SET [Comment] = 'Occurs when a task voluntarily yields the scheduler for other tasks to execute. During this wait, the task is waiting in a runnable queue for its quantum to be renewed, i.e. waiting to be scheduled to run on the CPU again. Prolonged waits on this wait type most frequently indicate opportunities to optimize queries that perform index or table scans. Focus on plan regression, missing index, stats updates, query re-writes. Optimizing runtimes reduces the need for tasks to be yielding multiple times. If query times for such CPU-consuming tasks are acceptable, then this wait type is expected and can be ignored.---------------------
		This is an indication of CPU contention.

' 
			WHERE  dbo.[#results].[wait_type] = 'SOS_SCHEDULER_YIELD'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		UPDATE [dbo].[#results] SET [Comment] = 'Occurs with parallel query plans when waiting to synchronize the Query Processor Exchange Iterator, and when producing and consuming rows. If waiting is excessive and cannot be reduced by tuning the query (such as adding indexes), consider adjusting the Cost Threshold for Parallelism or lowering the Max Degree of Parallelism (MaxDOP).

		Note: Starting with SQL Server 2016 (13.x) SP2 and SQL Server 2017 (14.x) CU3, CXPACKET only refers to waiting to synchronize the Exchange Iterator and producing rows. Threads consuming rows are tracked separately in the CXCONSUMER wait type. If the consumer threads are too slow, the Exchange Iterator buffer may become full and cause CXPACKET waits. ---------------------
		This is an indication of parallel query execution. It indicates that a SPID is waiting on a parallel process to complete or start. The CXPacket wait type occurs when trying to synchronize the query processor exchange iterator. There are several things we can do to influence this:  we can turn parallelism off, we can limit parallelism by changing the setting max degree of parallelism, we can adjust the threshold of when parallelism is considered by changing the setting cost threshold for parallelism, or we can review queries that suffer from this wait type and see if adding indexes will help.
		PARALLELISM - Occurs with parallel query plans when waiting to synchronize the Query Processor Exchange Iterator, and when producing and consuming rows. If waiting is excessive and cannot be reduced by tuning the query (such as adding indexes), consider adjusting the Cost Threshold for Parallelism or lowering the Max Degree of Parallelism (MaxDOP).

' 
			WHERE  dbo.[#results].[wait_type] = 'CXPACKET'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'PARALLELISM - This type should reduce the number of actionable CXPACKET waits that occur. This is a normal part of parallel query execution.

'
			WHERE  dbo.[#results].[wait_type] = 'CXCONSUMER'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'Occurs on network writes when the task is blocked waiting for the client application to acknowledge it has processed all the data sent to it. Verify that the client application is processing data from the server as fast as possible or that no network delays exist. Reasons the client application cannot consume data fast enough include: application design issues like writing results to a file while the results arrive, waiting for user input, client-side filtering on a large dataset instead of server-side filtering, or an intentional wait introduced. Also the client computer may be experiencing slow response due to issues like low virtual/physical memory, 100% CPU consumption, etc. Network delays can also lead to this wait - typically caused by network adapter driver issues, filter drivers, firewalls or misconfigured routers.---------------------
		The ASYNC_NETWORK_IO wait types can point to network related issues, but most often are caused by a client application that is not processing results from the SQL Server quickly enough. This will result in filling the network buffers so that SQL Server cannot send more data to the client. Therefore, the process executing the batch will need to wait for the ability to continue sending results to the client. If there are significant wait times on ASYNC_NETWORK_IO, review the client applications. Most often, client applications will process rows one at a time using fetches. This may cause the server process to wait on ASYNC_NETWORK_IO when serving up many rows. If this is the issue, there is nothing you can do to improve the SQL Server process performance. Instead, the client application (or middle tier if a web application) may need to be modified to allow for more efficient retrieval of data.

' 
			WHERE  dbo.[#results].[wait_type] = 'ASYNC_NETWORK_IO'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Bulk Update (BU) lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_BU'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Intent Shared (IS) lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_IS'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Intent Update (IU) lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_IU'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Intent Exclusive (IX) lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_IX'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a NULL lock on the current key value and an Insert Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RIn_NL'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a shared lock on the current key value and an Insert Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RIn_S' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Update lock on the current key value, and an Insert Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RIn_U' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Exclusive lock on the current key value, and an Insert Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RIn_X' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Shared lock on the current key value, and a Shared Range lock between the current and previous

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RS_S'  
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Update lock on the current key value, and an Update Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RS_U'  
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Shared lock on the current key value, and an Exclusive Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RX_S'  
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Update lock on the current key value, and an Exclusive range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RX_U'  
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Exclusive lock on the current key value, and an Exclusive Range lock between the current and previous key

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_RX_X'  
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Shared lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_S'     
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Schema Modify lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_SCH_M' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Schema Modify lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_SCH_S' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Shared With Intent Update lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_SIU'   
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire a Shared With Intent Exclusive lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_SIX'   
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Update lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_U'     
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Update With Intent Exclusive lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_UIX'   
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting to acquire an Exclusive lock

' 
			WHERE  dbo.[#results].[wait_type] = 'LCK_M_X'     
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		



		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting for a DT (destroy) latch. This does not include buffer latches or transaction mark latches

' 
			WHERE  dbo.[#results].[wait_type] = 'LATCH_DT'    
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting for an EX (exclusive) latch. This does not include buffer latches or transaction mark latches. This is contention for some non-page structure inside SQL Server - so not related to IO or data at all.

' 
			WHERE  dbo.[#results].[wait_type] = 'LATCH_EX'    
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting for a KP (keep) latch. This does not include buffer latches or transaction mark latches

' 
			WHERE  dbo.[#results].[wait_type] = 'LATCH_KP'    
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting for an SH (share) latch. This does not include buffer latches or transaction mark latches

' 
			WHERE  dbo.[#results].[wait_type] = 'LATCH_SH'    
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'LOCK - Waiting for an UP (update) latch. This does not include buffer latches or transaction mark latches

' 
			WHERE  dbo.[#results].[wait_type] = 'LATCH_UP'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'MEMORY - Occurs when a query memory request during query execution cannot be granted immediately due to other concurrent queries. High waits and wait times may indicate excessive number of concurrent queries, or excessive memory request amounts. Excessive waits of this type may raise SQL error 8645, "A time out occurred while waiting for memory resources to execute the query. Rerun the query."

' 
			WHERE  dbo.[#results].[wait_type] = 'RESOURCE_SEMAPHORE'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'MEMORY - Occurs while a query waits for its request for a thread reservation to be fulfilled. It also occurs when synchronizing query compile and memory grant requests.

' 
			WHERE  dbo.[#results].[wait_type] = 'RESOURCE_SEMAPHORE_MUTEX'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'MEMORY - Occurs when the number of concurrent query compilations reaches a throttling limit. High waits and wait times may indicate excessive compilations, recompiles, or uncacheable plans.

' 
			WHERE  dbo.[#results].[wait_type] = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'MEMORY - Occurs when memory request by a small query cannot be granted immediately due to other concurrent queries. Wait time should not exceed more than a few seconds, because the server transfers the request to the main query memory pool if it fails to grant the requested memory within a few seconds. High waits may indicate an excessive number of concurrent small queries while the main memory pool is blocked by waiting queries.

Applies to: SQL Server 2008 R2 only.

' 
			WHERE  dbo.[#results].[wait_type] = 'RESOURCE_SEMAPHORE_SMALL_QUERY'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs while waiting for a log flush to complete. Common operations that cause log flushes are transaction commits and checkpoints. Common reasons for long waits on WRITELOG are: disk latency (where transaction log files reside), the inability for I/O to keep up with transactions, or, a large number of transaction log operations and flushes (commits, rollback).

' 
			WHERE  dbo.[#results].[wait_type] = 'WRITELOG'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Destroy mode. Long waits may indicate problems with the disk subsystem.

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGEIOLATCH_DT' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Exclusive mode - a mode used when the buffer is being written to disk. Long waits may indicate problems with the disk subsystem. 

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGEIOLATCH_EX' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Keep mode. Long waits may indicate problems with the disk subsystem.

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGEIOLATCH_KP' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Shared mode - a mode used when the buffer is being read from disk. Long waits may indicate problems with the disk subsystem.

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGEIOLATCH_SH' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Update mode. Long waits may indicate problems with the disk subsystem.

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGEIOLATCH_UP' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Destroy mode. Destroy mode must be acquired before deleting contents of a page. 

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGELATCH_DT' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Exclusive mode - it blocks other threads from writing to or reading from the page (buffer).
A common scenario that leads to this latch is the "last-page insert" buffer latch contention. To understand and resolve this, use Resolve last-page insert PAGELATCH_EX contention and Diagnose and resolve last-page-insert latch contention on SQL Server. Another scenario is Latch contention on small tables with a non-clustered index and random inserts (queue table).

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGELATCH_EX' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Keep mode which prevents the page from being destroyed by another thread. 

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGELATCH_KP' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Shared mode which allows multiple threads to read, but not modify, a buffer (page).

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGELATCH_SH' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Update mode. Commonly this wait type may be observed when a system page (buffer) like PFS, GAM, SGAM is latched. See Latch Modes for more information.
For troubleshooting a common scenario with this latch, refer to Reduce Allocation Contention in SQL Server tempdb database.

' 
			WHERE  dbo.[#results].[wait_type] = 'PAGELATCH_UP' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting for space in the log buffer to store a log record. Consistently high values may indicate that the log devices cannot keep up with the amount of log being generated by the server.

'
			WHERE  dbo.[#results].[wait_type] = 'LOGBUFFER' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs when a task is waiting for asynchronous non-data I/Os to finish. Examples include I/O involved in warm standby log shipping, database mirroring, some bulk import related operations.

'
			WHERE  dbo.[#results].[wait_type] = 'ASYNC_IO_COMPLETION' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		UPDATE [dbo].[#results] SET [Comment] = 'DISK - Occurs while waiting for I/O operations to complete. This wait type generally represents non-data page I/Os. Data page I/O completion waits appear as PAGEIOLATCH_* waits.

' 
			WHERE  dbo.[#results].[wait_type] = 'IO_COMPLETION' 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'Occurs when a task is waiting for an extended stored procedure to end. SQL Server uses this wait state to detect potential MARS application deadlocks. The wait stops when the extended stored procedure call ends.

' 
			where dbo.[#results].wait_type = 'MSQL_XP'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'Occurs when a task (query or login/logout) is waiting for a worker thread to execute it. This can indicate that the maximum worker thread setting is misconfigured, or that, most commonly, batch executions are taking unusually long, thus reducing the number of worker threads available to satisfy other batches. Examine the performance of batches (queries) and reduce query duration by either reducing bottlenecks (blocking, parallelism, I/O, latch waits), or providing proper indexing or query design.

' 
			where dbo.[#results].wait_type = 'THREADPOOL'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'AOAG - Waiting for a transaction commit processing on the synchronized secondary databases to harden the log. This wait is also reflected by the Transaction Delay performance counter. This wait type is expected for synchronous-commit Availability Groups and indicates the time to send, write, and acknowledge log commit to the secondary databases. 

'
			where dbo.[#results].wait_type like 'HADR_SYNC_COMMIT'


--INTERNAL ONLY - NEEDED???
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'AOAG - Indicates that one or more parallel redo worker threads cannot keep up with main redo thread transaction log dispatching speed or are blocked by some resources such as other type of waits.

'
			where dbo.[#results].wait_type like 'PARALLEL_REDO_FLOW_CONTROL'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'AOAG - Only happens in a readable secondary replica when new insert triggers page-split system transaction, or record update in a heap table generates a forwarded record

'
			where dbo.[#results].wait_type like 'PARALLEL_REDO_TRAN_TURN'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'AOAG - There is a wait on a lock that control access to dirty page table. This wait will not be generated anymore after the performance fix for concurrent read-only query and log redo is released.

' 
			where dbo.[#results].wait_type like 'DIRTY_PAGE_TABLE_LOCK'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		update dbo.[#results] set [Comment] = 'AOAG - Only occurs when parallel redo worker thread and a user query thread concurrently process redo operations for the same dirty page entry.

'
			where dbo.[#results].wait_type like 'DPT_ENTRY_LOCK'
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


	DECLARE Waits_Cursor CURSOR 
		FOR SELECT wait_type, Percentage, Comment 
			FROM dbo.#results 
			order by Percentage desc
	OPEN Waits_Cursor
	FETCH NEXT FROM Waits_Cursor
		into @wait, @percentage, @waitcomment

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @sCount = 1
			insert into #ActionableItems
				select 'TOP WAIT STATS > 20%', '012'
		if @sCount < 6 and @percentage >= 20
		begin
			insert into #ActionableItems
				select '     WAIT ' + cast(@sCount as varchar(2)) + ': ' + @wait + ' @ ' + cast(@percentage as varchar(5)) +'% ' + '
        ' + isnull(@waitcomment, ''), '013'
			set @sCount = @sCount + 1
		end
	
		FETCH NEXT FROM Waits_Cursor
			into @wait, @percentage, @waitcomment
	END
		   
	CLOSE Waits_Cursor
	DEALLOCATE Waits_Cursor

	/* View Final Results */
	if @bShowSettingsResults = 1
	begin
		--SELECT 'WAIT STATS'
		SELECT 'WAIT STATS' as 'WAIT STATS', 
		   wait_type AS 'Wait_Type'
		 , waiting_tasks_count AS 'Waiting_Tasks_Count'
		 , WaitS 'Wait_sec'
		 , ResourceS AS 'Resource_sec'
		 --, MAX_WAIT_TIME_MS AS 'MAX TIME WAITING (MS)'
		 , SignalS 'Signal_sec'
		 , Percentage as '%'
		 --, RowNum
		 , Comment AS 'POSSIBLE ISSUES'
		 FROM #results
		 WHERE waiting_tasks_count <> 0
		 ORDER BY WaitS DESC
	 end

	 /* Clean Up */
	DROP TABLE #results;
	--GO
end





--=================================================================================================
-- TOO MANY NCIs			

if @bIdxLevels = 1 and @bPDM = 0
begin
	declare @dbCount int,
			@tooManyTtl int;

	set @dbCount = 0;
	set @tooManyTtl = 0;
	
	IF OBJECT_ID(N'tempdb..#TooManyNCIs') IS NOT NULL
		DROP TABLE #TooManyNCIs
	create table #TooManyNCIs
	(
		dbName sysname,
		schName sysname,
		tblName sysname,
		count int
	)
	
	exec sp_MSforeachdb 'use [?];
	insert into #TooManyNCIs
	select  
		DB_NAME(db_id()) as DbName,
		schema_name(schema_id) as SchName,
		object_name(i.object_id) as TblName,
		count(i.object_id) as NCIcount 
	from sys.indexes i
		INNER JOIN sys.tables t 
			ON i.object_id = t.object_id 
	WHERE t.is_ms_shipped = 0   
		and i.index_id > 1	-- NCI
		and i.is_hypothetical = 0		--leave out hypotheticals; those are reported separately
	group by schema_id, i.object_id 
	ORDER BY schema_id, object_name(i.object_id)'

	if @bShowSettingsResults = 1
	begin
		select 'TOO MANY NCIs' as 'TOO MANY NCIs', * from #TooManyNCIs
		where count > 10
	end

	select @dbCount = count(distinct (dbName)) 
		from #TooManyNCIs 
		where count > 10

	select @tooManyTtl = count(*) 
		from #TooManyNCIs
		where count > 10
	
	if
	(select COUNT(*) from #TooManyNCIs where count > 10) > 0	 
	begin
		insert into #ActionableItems
			select 'Database(s) with too many indexes (10 or more indexes): ' + cast(@dbCount as varchar(5)), '124'
		insert into #ActionableItems
			select '    *** Tables with "too many indexes" (10 or more indexes): ' + cast(@tooManyTtl as varchar(5)) + '
     While some of these might be duplicate, if they are not but are close to it and can be combined, we may be able to delete some clearing up more space and alleviating your server of unneeded overhead from inserts/updates/deletes and maintenances. Any indexes that are truly duplicate should be considered for deletion.

', '125'
	end
	else						
		--print '       too many NCIs verified '
		insert into #ClearedItems
			select 'Too many NCIs verified.
			
', '124'

	-- CLEANUP
	drop table #TooManyNCIs
end


--=================================================================================================
-- HEAPS  w/ NO INDEXES
if @bIdxLevels = 1 and @bPDM = 0
begin
	declare @heapNoIdxCt int,
			@heapNoIdxTtl int;

	set @heapNoIdxCt = 0
	set @heapNoIdxTtl = 0

	IF OBJECT_ID(N'tempdb..#HeapsNoIdx') IS NOT NULL
		DROP TABLE #HeapsNoIdx

	create table #HeapsNoIdx
	(
		dbName sysname,
		schName sysname,
		tblName sysname,
	)
	
	EXEC sp_MSforeachdb 'USE [?] 
	insert into #HeapsNoIdx
		SELECT ''?'' AS DbName,
			schema_name(o.schema_id) as schName,
			o.name as tblName
		FROM sys.indexes i
			INNER JOIN sys.objects o
				ON  i.object_id = o.object_id
		WHERE (o.type_desc = ''USER_TABLE''
			AND i.type_desc = ''HEAP''
			and o.is_ms_shipped = 0		--ignore tables that are shipped with MS SQL
			and db_id() > 4		--only check user DBs
			and DB_NAME(DB_ID()) not like ''ReportServer%''
			--this next section will exclude tables with NCIs
			and not exists (select i.index_id 
							from sys.indexes i 
							where i.type <> 0 --ignore default heap index row
							and o.object_id = i.object_id ))'

	select 'NO INDEXES' as 'HEAPS', * from #HeapsNoIdx

	select @heapNoIdxCt = count(distinct (dbName)) from #HeapsNoIdx where DBName not like 'ReportServer%'
	select @heapNoIdxTtl = count(tblName) from #HeapsNoIdx where DBName not like 'ReportServer%'

	if
	(select COUNT(*) from #HeapsNoIdx) > 0	 
	begin
		insert into #ActionableItems
			select 'Database(s) with NO INDEXES: ' + cast(@heapNoIdxCt as varchar(5)), '126'
		insert into #ActionableItems
			select '    *** Total number of Tables w/ NO INDEXES: ' + cast(@heapNoIdxTtl as varchar(5)) + '
     Having no indexes on these tables means that every query against these tables will result in a table scan meaning the entire table must be read to find any row. Additionally, any records that are updated and that do not fit on the page holding that data will get moved to a new page with a forwarding record pointer written in its place. This introduces fragmentation in the heap. When scanning a heap, these pointers must be followed which limits read-ahead performance, and can incur additional I/O which reduces scan performance. Heaps can be acceptable if the table is small or if the table is used as staging tables for large, unordered insert operations. Heaps should not be used when data is frequently returned in a sorted order, frequently grouped together (as data must be sorted before it is grouped), frequently updated, or if ranges of data are frequently queried from the table.

', '127'
	end
	else						
		--print '       tables with NO INDEXES verified'
		insert into #ClearedItems
			select 'Tables w/ NO INDEXES verified.

', '126'

	--CLEANUP
	drop table #HeapsNoIdx
end


--=================================================================================================
-- HEAPS w/ INDEXES
if @bIdxLevels = 1 and @bPDM = 0
begin
	declare @heapIdxCt int,
			@heapIdxTtl int;

	set @heapIdxCt = 0
	set @heapIdxTtl = 0;

	IF OBJECT_ID(N'tempdb..#HeapsWIdx') IS NOT NULL
		DROP TABLE #HeapsWIdx

	create table #HeapsWIdx
	(
		dbName sysname,
		schName sysname,
		tblName sysname,
	)
	
	EXEC sp_MSforeachdb 'USE [?] 
	insert into #HeapsWIdx
		SELECT  ''?'' AS DatabaseName,
			schema_name(o.schema_id) as schName,
			o.name as tblName
		FROM sys.indexes i
			INNER JOIN sys.objects o
				ON  i.object_id = o.object_id
		WHERE o.type_desc = ''USER_TABLE''
			AND i.type_desc = ''HEAP''
			and o.is_ms_shipped = 0		--ignore tables that are shipped with MS SQL
			and db_id() > 4		--only user DBs
			and DB_NAME(DB_ID()) not like ''ReportServer%''
			and exists (select i.index_id 
						from sys.indexes i 
						where i.type > 1 --NCIs
						and o.object_id = i.object_id )'

	select 'NO CLUSTERED INDEX' as 'HEAPS', * from #HeapsWIdx
	select @heapIdxCt = count(distinct (dbName)) from #HeapsWIdx where dbName not like 'ReportServer%'
	select @heapIdxTtl = count(tblName) from #HeapsWIdx where dbName not like 'ReportServer%'

	if @heapIdxTtl > 0	 
	begin
		insert into #ActionableItems
			select 'Database(s) with NO Clustered Index: ' + cast(@heapIdxCt as varchar(5)), '128'
		insert into #ActionableItems
			select '    *** Total number of Tables w/ NO Clustered Index: ' + cast(@heapIdxTtl as varchar(5)) + '
     While these tables have nonclustered indexes, they are still unordered which means any sorts on this data will have to rely on tempdb. Additionally, any records that are updated and that do not fit on the page holding that data will get moved to a new page with a forwarding record pointer written in its place. This introduces fragmentation in the heap. When scanning a heap, these pointers must be followed which limits read-ahead performance, and can incur additional I/O which reduces scan performance. Heaps can be acceptable if the table is small or if the table is used as staging tables for large, unordered insert operations. Heaps should not be used when data is frequently returned in a sorted order, frequently grouped together (as data must be sorted before it is grouped), frequently updated, or if ranges of data are frequently queried from the table.

', '129'
	end
	else						
		--print '       heaps w/ NCIs verified '
		insert into #ClearedItems
			select 'Tables w/ NO Clustered Index verified.
			
', '128'

	--CLEANUP
	drop table #HeapsWIdx
end


--=================================================================================================

-- DUPLICATE
-- THIS DOES NOT FACTOR IN THE ORDER OF THE SORT (ASC VS DESC), and WILL ALSO REPORT A UNIQUE PRIMARY KEY AS IDENTICAL TO A NON-UNIQUE, NONCLUSTERED INDEX IF THEY HAVE THE SAME COLUMNS

if @bIdxLevels = 1 and @bPDM = 0
begin
	declare @dupCount int,
			@dupTtl int;
	set @dupCount = 0
	set @dupTtl = 0;

	IF OBJECT_ID(N'tempdb..#DupIdx') IS NOT NULL
		DROP TABLE #DupIdx

	create table #DupIdx
	(
		dbName sysname,
		schTbl sysname,
		name1 sysname,
		name2 sysname
	)
	
	--SELECT 'DUPLICATE INDEXES';
	EXEC master.dbo.sp_MSforeachdb '
	use [?]
	IF ''?'' <> ''master'' AND ''?'' <> ''model'' AND ''?'' <> ''msdb'' AND ''?'' <> ''tempdb'' AND ''?'' <> ''ReportServer'' AND ''?'' <> ''ReportServerTempDB'' 
	BEGIN
	use [?]

	;WITH indexcols AS
	(
		SELECT object_id AS id, index_id as indid, name,is_unique,
			(SELECT CASE keyno WHEN 0 THEN NULL ELSE colid END AS [data()]
				FROM sys.sysindexkeys AS k
				WHERE k.id = i.object_id
				AND k.indid = i.index_id
				ORDER BY keyno, colid
				FOR XML PATH('''')) AS cols,
			(SELECT CASE keyno WHEN 0 THEN colid ELSE NULL END AS [data()]
				FROM sys.sysindexkeys AS k
				WHERE k.id = i.object_id
				AND k.indid = i.index_id
				ORDER BY colid
				FOR XML PATH('''')) AS inc
		FROM sys.indexes AS i
		where is_hypothetical = 0		-- ADDED THIS JUST RECENTLY AS GETTING RID OF HYPOTHETICALS WILL ELIMINATE MANY OF THESE
		and OBJECTPROPERTY (i.object_id,''IsMsShipped'') = 0	--ignore system/internal indexes
	)

	insert into #DupIdx
		SELECT ''?'' as DBName,
			object_schema_name(c1.id) + ''.'' + object_name(c1.id) as ''table'',
			c1.name AS ''index'',
			c2.name AS ''exactduplicate''
		FROM indexcols AS c1
			JOIN indexcols AS c2
		ON c1.id = c2.id
			AND c1.indid < c2.indid
			AND c1.cols = c2.cols
			AND c1.inc = c2.inc
			AND c1.is_unique = c2.is_unique;
	end
	'
	if @bShowSettingsResults = 1
	begin
		select 'DUPLICATE INDEXES' as 'DUPLICATE INDEXES', * from #DupIdx
	end
	---------------------------
	select @dupCount = count(distinct(dbName)) from #DupIdx 
	select @dupTtl = count(*) from #DupIdx
	
	if @dupTtl > 0
	begin
		insert into #ActionableItems
			select 'Database(s) with duplicate indexes: ' + cast(@dupCount as varchar(5)), '132'
		insert into #ActionableItems
			select '    *** Total "duplicate indexes" (amongst all databases): ' + cast(@dupTtl as varchar(5)) + '
     Having duplicate indexes means more unnecessary overhead with regard to inserts/updates/deletes and maintenance. Please review and delete as needed.

', '133'
	end
	else						
		--print '       duplicate indexes verified '
		insert into #ClearedItems
			select 'Duplicate indexes verified.
			
', '132'

	------------

	-- CLEANUP
	drop table #DupIdx
end


--=================================================================================================
-- HYPOTHETICAL INDEXES

if @bIdxLevels = 1 and @bPDM = 0
begin
	--SELECT 'HYPOTHETICAL INDEXES'
	-- Set database context
	USE master

	declare @HypCt int,
			@HypTtl int
	set @HypCt = 0
	set @HypTtl = 0

	-- Drop temporary table if exists
	IF OBJECT_ID('tempDB.dbo.#HypotheticalIndexDropScript') IS NOT NULL
		DROP TABLE #HypotheticalIndexDropScript;
    
	-- Create Temporary Table
	CREATE TABLE #HypotheticalIndexDropScript
		(
		  DatabaseName VARCHAR(255) ,
		  TableName varchar(150),
		  HypotheticalIndex varchar(4000),
		  HypotheticalIndexScript VARCHAR(4000)
		);

	INSERT  INTO #HypotheticalIndexDropScript
			EXEC sp_MSforeachdb 'USE [?]; 
			SELECT  DB_NAME(DB_ID()), 
			''['' + SCHEMA_NAME(o.[schema_id]) + ''].'' + ''['' + OBJECT_NAME(o.[object_id]) + '']'' as TableName,
			i.name  AS HypotheticalIndexes,
			''USE '' + ''['' + DB_NAME(DB_ID()) + ''];'' + '' IF  EXISTS (SELECT 1 FROM sys.indexes  AS i WHERE i.[object_id] = '' + ''object_id('' + + '''''''' + ''['' + SCHEMA_NAME(o.[schema_id]) + ''].'' + ''['' +  OBJECT_NAME(i.[object_id]) + '']'' + '''''''' + '')'' + '' AND name = '' + '''''''' + i.NAME + '''''''' + '') ''    
		   + '' DROP INDEX '' + ''['' + i.name + '']'' + '' ON '' + ''['' + SCHEMA_NAME(o.[schema_id]) + ''].'' + ''['' + OBJECT_NAME(o.[object_id]) + ''];'' AS HypotheticalIndexesScript

	FROM    sys.indexes i
			INNER JOIN sys.objects o ON o.[object_id] = i.[object_id]
	WHERE is_hypothetical = 1'

	IF @bShowSettingsResults = 1
		select 'HYPOTHETICAL INDEXES' as 'HYPOTHETICAL INDEXES', * from #HypotheticalIndexDropScript
	
	select @HypCt = count(distinct(DatabaseName)) from #HypotheticalIndexDropScript
	select @HypTtl = count(*) from #HypotheticalIndexDropScript

	if @HypCt > 0
	begin
		insert into #ActionableItems
			select 'Database(s) with hypothetical indexes: ' + cast(@HypCt as varchar(5)), '134'
		insert into #ActionableItems
			select '    *** Total hypothetical indexes: ' + cast(@HypTtl as varchar(5)) + '
     Hypothetical indexes and stats are created by the Database Engine Tuning Advisor and they are normally removed when it completes. However, if DTA fails or is killed before it can complete, hypothetical indexes can remain. They are not usable but can be a nuisance when index tuning (making you think that a certain index already exists when really it does not).

', '135'
	end
	else						
		insert into #ClearedItems
			select 'Hypothetical indexes verified.

', '134'

	------------

	--CLEANUP
	drop table #HypotheticalIndexDropScript
end





--=================================================================================================



--print '   
-----------------------------------------
--  !!!!! VERIFICATIONS  COMPLETE !!!!!
	 

--' 




--=================================================================================================
--indexes
------------------- INDEX FRAGMENTATION

if @bIdxFragLevels = 1		
begin
	declare @fragCt int
	set @fragCt = 0

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#IndexFrag') IS NOT NULL
		DROP TABLE #IndexFrag

	-- create temporary table
	CREATE TABLE #IndexFrag
	(
		[INDEX FRAGMENTATION] sysname,
		DbName sysname,
		SchName sysname,
		TblName sysname,
		IdxName sysname,
		IdxDesc nvarchar(60),
		AllocUnitType nvarchar(60),
		fillFact tinyint,
		frag_percent float,
		page_count bigint
	)

	declare @sqlfrag nvarchar(max)
	declare @dbnm nvarchar(30)
	;with     Agg_IO_Stats3
	as       (select   top 1 DB_NAME(d.database_id) as database_name,
						convert(varchar, cast(SUM(num_of_writes) as money), 1) AS 'Number of Writes'
				from     sys.dm_io_virtual_file_stats (null, null) as s
				inner join sys.databases d
				on s.database_id = d.database_id
				where    s.database_id > 4
				and d.state = 0
				and d.source_database_id IS NULL
				group by s.database_id, d.database_id
				ORDER BY SUM(num_of_writes) DESC)

	select @dbnm =  database_name
	from     Agg_IO_Stats3

	select @sqlfrag='USE ['+ @dbnm + ']		--change db name here if you want to run against a different db

	select ''INDEX FRAGMENTATION'', DB_NAME(d.database_id), OBJECT_SCHEMA_NAME(d.object_id, d.database_id) as [Schema],
				OBJECT_NAME(d.object_id, d.database_id) as [TblName],
				s.name AS IdxName,
				index_type_desc [Idx Desc],
				alloc_unit_type_desc [Alloc Unit Type], 
				s.fill_factor,
				avg_fragmentation_in_percent as [Fragmentation %],
				page_count [Page Count]	-- indexes with page count < 1000 are skipped, by default, in Ola''s script
	FROM sys.dm_db_index_physical_stats (db_id(), NULL, NULL, NULL, NULL) d		-- db_id() will not work when compatibility level < 90
			INNER JOIN sys.indexes s   
			ON d.object_id = s.object_id 
			AND d.index_id = s.index_id 
	where page_count >= 1000 and index_type_desc <> ''HEAP''
	order by [Fragmentation %] desc'

	insert into #IndexFrag
		exec(@sqlfrag)

	select * from #IndexFrag
	select @fragCt = count(*) from #IndexFrag where frag_percent >= 30 

	if @fragCt> 0
		insert into #ActionableItems
			select 'There are ' + cast(@fragCt as varchar(5)) + ' index(es) that have fragmentation >= 30%. This can be due to two things: either you don''t have an index maintenance job or you do but it doesn''t run often enough.
     If you don''t have a job, we recommend adopting a targeted approach to index maintenance using the solution outlined here:  http://ola.hallengren.com/.
     This approach looks at index fragmentation on an index by index basis and depending on the severity of the fragmentation, rebuilds or reorganizes an index. In addition, it also only updates statistics that need updating. In the long run, it will use fewer resources than a standard maintenance plan in which all indexes are rebuilt for certain databases.
     If you already have a job, then perhaps the parameters of the job or the schedule need to be re-evaluated.
			
', '121'
	else
		insert into #ClearedItems
			select 'Index fragmentation verified.

', '121'

	------------

	--cleanup
	drop table #IndexFrag

end

--=================================================================================================
--stats
------------------- STATISTICS
if @bStatsLevels = 1
begin
	declare @statsCt int
	set @statsCt = 0

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#statsCheck') IS NOT NULL
		DROP TABLE #statsCheck

	-- create temporary table
	CREATE TABLE #statsCheck
	(
		[STATISTICS] sysname,
		DbName sysname,
		Objectname sysname,
		StatisticsName sysname,
		StatisticsUpdateDate datetime
	)

	IF OBJECT_ID('tempdb.dbo.#statsCheck2') IS NOT NULL
		DROP TABLE #statsCheck2

	CREATE TABLE #statsCheck2
	(
		DbName sysname,
		MostRecentStatsUpdate datetime
	)

	EXEC master.dbo.sp_MSforeachdb '
	use [?]
	IF ''?'' <> ''master'' AND ''?'' <> ''model'' AND ''?'' <> ''msdb'' AND ''?'' <> ''tempdb''
	BEGIN
	use [?]
	insert into #statsCheck
		SELECT ''STATISTICS'',
				''?'', 
				OBJECT_NAME(object_id),
				[name],
				STATS_DATE([object_id], [stats_id])
		FROM sys.stats
		
	end
	'
	select * from #statsCheck
	order by DbName, StatisticsUpdateDate desc

	select DbName, max(StatisticsUpdateDate) as [MostRecentStatsUpdate]
		from #statsCheck
		group by DbName

	insert into #statsCheck2
		select DbName, max(StatisticsUpdateDate) as [MostRecentStatsUpdate]
		from #statsCheck
		group by DbName

	select @statsCt = count(*) from #statsCheck2 where MostRecentStatsUpdate < (getdate() - 30)

	select @statsCt as StatsCt
	
	if @statsCt = 1
		insert into #ActionableItems
			select 'There is ' + cast(@statsCt as varchar(5)) + ' database that has its most recent statistics date older than 30 days. 
			
', '122'
	else if @statsCt > 1
		insert into #ActionableItems
			select 'There are ' + cast(@statsCt as varchar(5)) + ' databases that have their most recent statistics date older than 30 days. 
			
', '122'
	else
		insert into #ClearedItems
			select 'Statistics verified.

', '122'


	------------

	--cleanup
	drop table #statsCheck
	drop table #statsCheck2

end


--=================================================================================================

-- MISSING
if @bIdxLevels = 1 and @bPDM = 0
begin  
	SELECT @lastSQLRestart as [LastSQLRestart]
	DECLARE @runtime datetime
	DECLARE @missingIdxDMVCt int
	SET @runtime = GETDATE()
	SET @missingIdxDMVCt = 0

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#missingIdxDMV') IS NOT NULL
		DROP TABLE #missingIdxDMV

	-- create temporary table
	CREATE TABLE #missingIdxDMV
	(
		[MISSING INDEXES DMV] sysname,
		RunTime datetime,
		ImprovementMeasure money,
		[Database.Schema.Table] nvarchar (4000),
		Avg_Total_User_Cost float,
		Avg_User_Impact float,
		User_Seeks bigint,
		User_Scans bigint,
		[Database_ID] smallint,
		[Object_ID] int,
		[create_index_statement] nvarchar(max)
	)

	insert into #missingIdxDMV
		SELECT 'MISSING INDEXES DMV', 
		CONVERT (varchar, @runtime, 126),
		convert(varchar, cast(migs.avg_total_user_cost * migs.avg_user_impact/100 * (migs.user_seeks + migs.user_scans) as money), 1)  AS improvement_measure,
		mid.statement as 'Database.Schema.Table',  
		migs.Avg_Total_User_Cost, 
		migs.Avg_User_Impact, 
		migs.User_Seeks, 
		migs.User_Scans, 
		mid.Database_ID, 
		mid.[Object_ID], 
		'CREATE INDEX IX_MI_' + object_name(mid.object_id, mid.database_id) + '_' + CONVERT (varchar, mig.index_group_handle) + '_' + CONVERT (varchar, mid.index_handle)  + ' ON ' + mid.statement + ' (' + ISNULL (mid.equality_columns,'')  + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '') + ')' + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
		FROM sys.dm_db_missing_index_groups mig  with (nolock)
						INNER JOIN sys.dm_db_missing_index_group_stats migs  with (nolock) ON migs.group_handle = mig.index_group_handle
						INNER JOIN sys.dm_db_missing_index_details mid  with (nolock) ON mig.index_handle = mid.index_handle
		WHERE migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) > 10000
		ORDER BY (migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans)) DESC

		select * from #missingIdxDMV
		order by ImprovementMeasure desc

		select @missingIdxDMVCt = count (*) from #missingIdxDMV where ImprovementMeasure >= 10000

		if @missingIdxDMVCt = 1
			insert into #ActionableItems
				select 'The Missing Indexes DMV shows there is ' + cast(@missingIdxDMVCt as varchar(5)) + ' missing index with an improvement measure >= 10,000' +  + '. It still needs to be evaluated to see if it is a duplicate or can be combined with other indexes.
				
', '121'
		else if @missingIdxDMVCt > 1 
			insert into #ActionableItems
				select 'The Missing Indexes DMV shows there are ' + cast(@missingIdxDMVCt as varchar(5)) + ' missing indexes with an improvement measure >= 10,000' +  + '. These still need to be evaluated to see if any are duplicates or can be combined with other indexes.
				
', '121'
		else
			insert into #ClearedItems
				select 'Missing Indexes DMV verified.

', '121'

end


-- or MISSING FROM PLAN CACHE w QUERIES
/*
	These values will be slightly different because they come from the plan cache. If the plan has aged out of the plan cache, the missing index information goes with it. 
*/
--SELECT 'MISSING INDEXES PLAN CACHE'          
if @bIdxLevels = 1 and @bPDM = 0
begin                                         
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#missingIdxCache') IS NOT NULL
		DROP TABLE #missingIdxCache

	-- create temporary table
	CREATE TABLE #missingIdxCache
	(
		[MISSING INDEXES PLAN CACHE'] sysname
	)

set ansi_warnings on
;WITH     XMLNAMESPACES (DEFAULT 'http://schemas.microsoft.com/sqlserver/2004/07/showplan'),
         PlanMissingIndexes
AS       (SELECT query_plan,
                 usecounts
          FROM   sys.dm_exec_cached_plans AS cp CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle) AS qp
          WHERE  qp.query_plan.exist('//MissingIndexes') = 1),
         MissingIndexes
AS       (SELECT stmt_xml.value('(QueryPlan/MissingIndexes/MissingIndexGroup/MissingIndex/@Database)[1]', 'sysname') AS DatabaseName,
                 stmt_xml.value('(QueryPlan/MissingIndexes/MissingIndexGroup/MissingIndex/@Schema)[1]', 'sysname') AS SchemaName,
                 stmt_xml.value('(QueryPlan/MissingIndexes/MissingIndexGroup/MissingIndex/@Table)[1]', 'sysname') AS TableName,
                 stmt_xml.value('(QueryPlan/MissingIndexes/MissingIndexGroup/@Impact)[1]', 'float') AS impact,
        --         stmt_xml.value('(@StatementSubTreeCost)[1]', 'VARCHAR(128)')
			     --   * ISNULL(stmt_xml.value('(./QueryPlan/MissingIndexes/MissingIndexGroup/@Impact)[1]','float'), 0)
				    --* pmi.usecounts AS Improvement ,
                 pmi.usecounts,
                 STUFF((SELECT DISTINCT ', ' + c.value('(@Name)[1]', 'sysname')
                        FROM   stmt_xml.nodes ('//ColumnGroup') AS t(cg) CROSS APPLY cg.nodes ('Column') AS r(c)
                        WHERE  cg.value('(@Usage)[1]', 'sysname') = 'EQUALITY'
                        FOR    XML PATH ('')), 1, 2, '') AS equality_columns,
                 STUFF((SELECT DISTINCT ', ' + c.value('(@Name)[1]', 'sysname')
                        FROM   stmt_xml.nodes ('//ColumnGroup') AS t(cg) CROSS APPLY cg.nodes ('Column') AS r(c)
                        WHERE  cg.value('(@Usage)[1]', 'sysname') = 'INEQUALITY'
                        FOR    XML PATH ('')), 1, 2, '') AS inequality_columns,
                 STUFF((SELECT DISTINCT ', ' + c.value('(@Name)[1]', 'sysname')
                        FROM   stmt_xml.nodes ('//ColumnGroup') AS t(cg) CROSS APPLY cg.nodes ('Column') AS r(c)
                        WHERE  cg.value('(@Usage)[1]', 'sysname') = 'INCLUDE'
                        FOR    XML PATH ('')), 1, 2, '') AS include_columns,
                 query_plan,
                 stmt_xml.value('(@StatementText)[1]', 'varchar(4000)') AS sql_text
          FROM   PlanMissingIndexes AS pmi CROSS APPLY query_plan.nodes ('//StmtSimple') AS stmt(stmt_xml)
          WHERE  stmt_xml.exist('QueryPlan/MissingIndexes') = 1)
SELECT   'MISSING INDEXES PLAN CACHE',
		 DatabaseName,
         SchemaName,
         TableName,
         equality_columns,
         inequality_columns,
         include_columns,
         --improvement as improvement_measure,
         usecounts,
         impact as [impact %],	-- expected to improve performance by this %; perhaps recommend if impact % is >= 85%
         query_plan,
         CAST ('<?query --' + CHAR(13) + sql_text + CHAR(13) + ' --?>' AS XML) AS SQLText,
         'CREATE NONCLUSTERED INDEX IX_' + REPLACE(REPLACE(REPLACE(SchemaName, '_', ''), '[', ''), ']', '') + '_' + REPLACE(REPLACE(REPLACE(TableName, '_', ''), '[', ''), ']', '') + '_' + COALESCE (REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(equality_columns, '_', ''), '[', ''), ']', ''), ',', ''), ' ', ''), '') + COALESCE (REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(COALESCE (inequality_columns, ''), '_', ''), '[', ''), ']', ''), ',', ''), ' ', ''), '') + ' ON ' + DatabaseName + '.' + SchemaName + '.' + TableName + '(' + STUFF(COALESCE (',' + equality_columns, '') + COALESCE (',' + inequality_columns, ''), 1, 1, '') + ')' + COALESCE (' INCLUDE (' + include_columns + ')', '')  AS PotentialDDL
FROM     MissingIndexes
WHERE    usecounts > 100
ORDER BY usecounts DESC, DatabaseName, SUM(usecounts) OVER (PARTITION BY DatabaseName, SchemaName, TableName) DESC, SUM(usecounts) OVER (PARTITION BY TableName, equality_columns, inequality_columns) DESC
end




--=================================================================================================
-- SP that consumes the most CPU resources
--SELECT 'MOST CPU RESOURCES'
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	--cursor variable
	declare @cpuCount smallint
	declare @dbNme1 sysname
	declare @schNme1 sysname
	declare @spNme1 sysname
	declare @execCount1 int
	declare @totalCPUtime bigint
	declare @avgCPUtime bigint
	set @cpuCount = 1

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#mostCPUsps') IS NOT NULL
		DROP TABLE #mostCPUsps

	-- create temporary table
	CREATE TABLE #mostCPUsps
	(
		DbName sysname,
		SchemaName sysname,
		StoredProc sysname,
		ExecCount int,
		Total_CPU_Time bigint,
		Avg_CPU_Time bigint
	)

	insert into #mostCPUsps
		SELECT 	DB_NAME(st.dbid) DBName
			,OBJECT_SCHEMA_NAME(st.objectid,dbid) SchemaName
			,OBJECT_NAME(st.objectid,dbid) StoredProcedure
			,max(cp.usecounts) Execution_count
			,sum(qs.total_worker_time) total_cpu_time
			,sum(qs.total_worker_time) / (max(cp.usecounts) * 1.0)  avg_cpu_time
		 FROM sys.dm_exec_cached_plans cp join sys.dm_exec_query_stats qs on cp.plan_handle = qs.plan_handle
			  CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
		 where DB_NAME(st.dbid) is not null and cp.objtype = 'proc'
		 group by DB_NAME(st.dbid),OBJECT_SCHEMA_NAME(objectid,st.dbid), OBJECT_NAME(objectid,st.dbid) 
		 order by sum(qs.total_worker_time) desc 

	--need top 3 to be in report here with #031 + 032
	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--total cursor
	DECLARE MostCPU_Cursor1 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, Total_CPU_Time 
			FROM dbo.#mostCPUsps 
			order by Total_CPU_Time desc
	OPEN MostCPU_Cursor1
	FETCH NEXT FROM MostCPU_Cursor1
		into @dbNme1, @schNme1, @spNme1, @execCount1, @totalCPUtime

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @cpuCount = 1
			insert into #ActionableItems
				select 'MOST CPU RESOURCES by Total CPU Time', '03a'
		if @cpuCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@cpuCount as varchar(2)) + ': ' + @dbNme1 + '.' +  @schNme1 + '.' + @spNme1 + '

' , '03b'
			set @cpuCount = @cpuCount + 1
		end
	
		FETCH NEXT FROM MostCPU_Cursor1
			into @dbNme1, @schNme1, @spNme1, @execCount1, @totalCPUtime
	END
		   
	CLOSE MostCPU_Cursor1
	DEALLOCATE MostCPU_Cursor1
	set @cpuCount = 1
	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--avg cursor
	DECLARE MostCPU_Cursor2 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, Total_CPU_Time, Avg_CPU_Time
			FROM dbo.#mostCPUsps 
			order by Avg_CPU_Time desc
	OPEN MostCPU_Cursor2
	FETCH NEXT FROM MostCPU_Cursor2
		into @dbNme1, @schNme1, @spNme1, @execCount1, @totalCPUtime, @avgCPUtime

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @cpuCount = 1
			insert into #ActionableItems
				select 'MOST CPU RESOURCES by Avg CPU Time', '03c'
		if @cpuCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@cpuCount as varchar(2)) + ': ' + @dbNme1 + '.' +  @schNme1 + '.' + @spNme1 + '

' , '03d'
			set @cpuCount = @cpuCount + 1
		end
	
		FETCH NEXT FROM MostCPU_Cursor2
			into @dbNme1, @schNme1, @spNme1, @execCount1, @totalCPUtime, @avgCPUtime
	END
		   
	CLOSE MostCPU_Cursor2
	DEALLOCATE MostCPU_Cursor2


	/* View Final Results */
	if @bShowSettingsResults = 1
	begin
		--SELECT 'MOST CPU RESOURCES'
		SELECT 'MOST CPU RESOURCES by Total CPU Time' as 'MOST CPU RESOURCES', *
		 FROM #mostCPUsps
		 group by DbName, SchemaName, StoredProc, ExecCount, Total_CPU_Time, Avg_CPU_Time
		 order by Total_CPU_Time desc 

		--SELECT 'MOST CPU RESOURCES'
		SELECT 'MOST CPU RESOURCES by Avg CPU Time' as 'MOST CPU RESOURCES', *
		 FROM #mostCPUsps
		 group by DbName, SchemaName, StoredProc, ExecCount, Total_CPU_Time, Avg_CPU_Time
		 order by Avg_CPU_Time desc 
	 end

	 /* Clean Up */
	drop table #mostCPUsps

end




-----------------------------------------------------------------------------
--SP that has executed the most I/O requests

--SELECT 'MOST I/O REQUESTS'
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	--cursor variable
	declare @ioCount smallint
	declare @dbNme2 sysname
	declare @schNme2 sysname
	declare @spNme2 sysname
	declare @execCount2 int
	declare @totalIO bigint
	declare @avgIO bigint
	set @ioCount = 1
	
	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#mostIOsps') IS NOT NULL
		DROP TABLE #mostIOsps
	
	-- create temporary table
	CREATE TABLE #mostIOsps
	(
		DbName sysname,
		SchemaName sysname,
		StoredProc sysname,
		ExecCount int,
		Ttl_IO bigint,
		Avg_IO bigint,
		Ttl_Phys_Reads bigint,
		Avg_Phys_Reads bigint,
		Ttl_Log_Reads bigint,
		Avg_Log_Reads bigint,
		Ttl_Log_Writes bigint,
		Avg_Log_Writes bigint
	)

	insert into #mostIOsps
		SELECT DB_NAME(st.dbid) DBName
			,OBJECT_SCHEMA_NAME(objectid,st.dbid) SchemaName
			,OBJECT_NAME(objectid,st.dbid) StoredProcedure
			,max(cp.usecounts) execution_count
			,sum(qs.total_physical_reads + qs.total_logical_reads + qs.total_logical_writes) total_IO
			,sum(qs.total_physical_reads + qs.total_logical_reads + qs.total_logical_writes) / (max(cp.usecounts)) avg_IO
			,sum(qs.total_physical_reads) total_physical_reads
			,sum(qs.total_physical_reads) / (max(cp.usecounts) * 1.0) avg_physical_read    
			,sum(qs.total_logical_reads) total_logical_reads
			,sum(qs.total_logical_reads) / (max(cp.usecounts) * 1.0) avg_logical_read  
			,sum(qs.total_logical_writes) total_logical_writes
			,sum(qs.total_logical_writes) / (max(cp.usecounts) * 1.0) avg_logical_writes  
		 FROM sys.dm_exec_query_stats qs CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) st
		   join sys.dm_exec_cached_plans cp on qs.plan_handle = cp.plan_handle
		  where DB_NAME(st.dbid) is not null and cp.objtype = 'proc'
		 group by DB_NAME(st.dbid),OBJECT_SCHEMA_NAME(objectid,st.dbid), OBJECT_NAME(objectid,st.dbid) 
		 order by sum(qs.total_physical_reads + qs.total_logical_reads + qs.total_logical_writes) desc


	--need top 3 to be in report here with #033 + 034
	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--total cursor
	DECLARE MostIO_Cursor1 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, Ttl_IO 
			FROM dbo.#mostIOsps 
			order by Ttl_IO desc
	OPEN MostIO_Cursor1
	FETCH NEXT FROM MostIO_Cursor1
		into @dbNme2, @schNme2, @spNme2, @execCount2, @totalIO

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @ioCount = 1
			insert into #ActionableItems
				select 'MOST I/O REQUESTS by Total IO', '03e'
		if @ioCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@ioCount as varchar(2)) + ': ' + @dbNme2 + '.' +  @schNme2 + '.' + @spNme2 + '

' , '03f'
			set @ioCount = @ioCount + 1
		end
	
		FETCH NEXT FROM MostIO_Cursor1
			into @dbNme2, @schNme2, @spNme2, @execCount2, @totalIO
	END
		   
	CLOSE MostIO_Cursor1
	DEALLOCATE MostIO_Cursor1
	set @ioCount = 1

	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--avg cursor
	DECLARE MostIO_Cursor2 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, Ttl_IO, Avg_IO 
			FROM dbo.#mostIOsps 
			order by Avg_IO desc
	OPEN MostIO_Cursor2
	FETCH NEXT FROM MostIO_Cursor2
		into @dbNme2, @schNme2, @spNme2, @execCount2, @totalIO, @avgIO

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @ioCount = 1
			insert into #ActionableItems
				select 'MOST I/O REQUESTS by Avg IO', '03g'
		if @ioCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@ioCount as varchar(2)) + ': ' + @dbNme2 + '.' +  @schNme2 + '.' + @spNme2 + '

' , '03h'
			set @ioCount = @ioCount + 1
		end
	
		FETCH NEXT FROM MostIO_Cursor2
			into @dbNme2, @schNme2, @spNme2, @execCount2, @totalIO, @avgIO
	END
		   
	CLOSE MostIO_Cursor2
	DEALLOCATE MostIO_Cursor2


	/* View Final Results */
	if @bShowSettingsResults = 1
	begin
		--SELECT 'MOST I/O REQUESTS'
		SELECT 'MOST I/O REQUESTS by Total IO' as 'MOST I/O REQUESTS', *
		 FROM #mostIOsps
		 group by DbName, SchemaName, StoredProc, ExecCount, Ttl_IO, Avg_IO, Ttl_Phys_Reads, Avg_Phys_Reads, Ttl_Log_Reads, Avg_Log_Reads, Ttl_Log_Writes, Avg_Log_Writes 
		 order by Ttl_IO desc 

		--SELECT 'MOST I/O REQUESTS'
		SELECT 'MOST I/O REQUESTS by Avg IO' as 'MOST I/O REQUESTS', *
		 FROM #mostIOsps
		 group by DbName, SchemaName, StoredProc, ExecCount, Ttl_IO, Avg_IO, Ttl_Phys_Reads, Avg_Phys_Reads, Ttl_Log_Reads, Avg_Log_Reads, Ttl_Log_Writes, Avg_Log_Writes 
		 order by Avg_IO desc 
	 end

	 /* Clean Up */
	drop table #mostIOsps


end




-----------------------------------------------------------------------------
--SP's take the longest time to execute
--SELECT 'LONGEST TIME TO EXECUTE'
if @bShowSettingsResults = 1 and @bPDM = 0
begin
	--cursor variables
	declare @longestCount smallint
	declare @dbNme3 sysname
	declare @schNme3 sysname
	declare @spNme3 sysname
	declare @execCount3 int
	declare @ttlElapsed bigint
	declare @avgElapsed bigint
	set @longestCount = 1

	-- drop temporary table if exists
	IF OBJECT_ID('tempdb.dbo.#longestTimeSPs') IS NOT NULL
		DROP TABLE #longestTimeSPs

	-- create temporary table
	CREATE TABLE #longestTimeSPs
	(
		DbName sysname,
		SchemaName sysname,
		StoredProc sysname,
		ExecCount int,
		TotalElapsedTime bigint,
		AvgElapsedTime bigint
	)

	insert into #longestTimeSPs
		SELECT DB_NAME(st.dbid) DBName
			  ,OBJECT_SCHEMA_NAME(objectid,st.dbid) SchemaName
			  ,OBJECT_NAME(objectid,st.dbid) StoredProcedure
			  ,max(cp.usecounts) execution_count
			  ,sum(qs.total_elapsed_time) total_elapsed_time
			  ,sum(qs.total_elapsed_time) / max(cp.usecounts) avg_elapsed_time
		 FROM sys.dm_exec_query_stats qs CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) st
		   join sys.dm_exec_cached_plans cp on qs.plan_handle = cp.plan_handle
		  where DB_NAME(st.dbid) is not null and cp.objtype = 'proc'
		 group by DB_NAME(st.dbid),OBJECT_SCHEMA_NAME(objectid,st.dbid), OBJECT_NAME(objectid,st.dbid) 
		 order by sum(qs.total_elapsed_time) desc


	--need top 3 to be in report here with #035 + 036
	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--total cursor
	DECLARE LongestTime_Cursor1 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, TotalElapsedTime
			FROM dbo.#longestTimeSPs 
			order by TotalElapsedTime desc
	OPEN LongestTime_Cursor1
	FETCH NEXT FROM LongestTime_Cursor1
		into @dbNme3, @schNme3, @spNme3, @execCount3, @ttlElapsed

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @longestCount = 1
			insert into #ActionableItems
				select 'LONGEST TIME TO EXECUTE by Total Elapsed Time', '03i'
		if @longestCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@longestCount as varchar(2)) + ': ' + @dbNme3 + '.' +  @schNme3 + '.' + @spNme3 + '

' , '03j'
			set @longestCount = @longestCount + 1
		end
	
		FETCH NEXT FROM LongestTime_Cursor1
			into @dbNme3, @schNme3, @spNme3, @execCount3, @ttlElapsed
	END
		   
	CLOSE LongestTime_Cursor1
	DEALLOCATE LongestTime_Cursor1
	set @longestCount = 1
		--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--avg cursor
	DECLARE LongestTime_Cursor2 CURSOR FOR 
		SELECT DbName, SchemaName, StoredProc, ExecCount, TotalElapsedTime, AvgElapsedTime
			FROM dbo.#longestTimeSPs 
			order by AvgElapsedTime desc
	OPEN LongestTime_Cursor2
	FETCH NEXT FROM LongestTime_Cursor2
		into @dbNme3, @schNme3, @spNme3, @execCount3, @ttlElapsed, @avgElapsed

	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @longestCount = 1
			insert into #ActionableItems
				select 'LONGEST TIME TO EXECUTE by Avg Elapsed Time', '03k'
		if @longestCount < 4
		begin
			insert into #ActionableItems
				select '     sproc ' + cast(@longestCount as varchar(2)) + ': ' + @dbNme3 + '.' +  @schNme3 + '.' + @spNme3 + '

' , '03l'
			set @longestCount = @longestCount + 1
		end
	
		FETCH NEXT FROM LongestTime_Cursor2
			into @dbNme3, @schNme3, @spNme3, @execCount3, @ttlElapsed, @avgElapsed
	END
		   
	CLOSE LongestTime_Cursor2
	DEALLOCATE LongestTime_Cursor2


	/* View Final Results */
	if @bShowSettingsResults = 1
	begin
		--SELECT 'LONGEST TIME TO EXECUTE'
		SELECT 'LONGEST TIME TO EXECUTE by Total Elapsed Time' as 'LONGEST TIME TO EXECUTE', *
		 FROM #longestTimeSPs
		 group by DbName, SchemaName, StoredProc, ExecCount, TotalElapsedTime, AvgElapsedTime
		 order by TotalElapsedTime desc 

		--SELECT 'LONGEST TIME TO EXECUTE'
		SELECT 'LONGEST TIME TO EXECUTE by Avg Elapsed Time' as 'LONGEST TIME TO EXECUTE', *
		 FROM #longestTimeSPs
		 group by DbName, SchemaName, StoredProc, ExecCount, TotalElapsedTime, AvgElapsedTime
		 order by AvgElapsedTime desc 	 
	 end

	 /* Clean Up */
	drop table #longestTimeSPs


end







 --=================================================================================================
 --OUTPUT RESULTS
 set @acount = 1
 set @ccount = 1

 --Actionable
DECLARE Actionable_Cursor CURSOR 
	FOR SELECT item, category FROM [dbo].[#ActionableItems] order by category, item 
OPEN Actionable_Cursor
FETCH NEXT FROM Actionable_Cursor
	into @aitem, @category

print '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ACTIONABLE ITEMS     
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'

WHILE @@FETCH_STATUS = 0
BEGIN
	begin
		-- do not add the number counter
		if @category = '013' or  @category = '125' or @category = '127' or @category = '129'  or @category = '131' or @category = '133' or @category = '135' or @category = '000'  or @category = '010' or @category = '050' or @category = '060' or @category = '110' or @category = '120' or @category = '03b' or @category = '03d' or @category = '03f' or @category = '03h' or @category = '03j' or @category = '03l' 
			 print @aitem
		else
		begin
			--print @category 
			print cast(@acount as varchar(2)) + '. ' + @aitem
			set @acount += 1
		end
	end
	
	FETCH NEXT FROM Actionable_Cursor
		into @aitem, @category
END
		   
CLOSE Actionable_Cursor
DEALLOCATE Actionable_Cursor


--Cleared
set @ccount = @acount
DECLARE Cleared_Cursor CURSOR 
	FOR SELECT item, category FROM [dbo].[#ClearedItems] order by category 
OPEN Cleared_Cursor
FETCH NEXT FROM Cleared_Cursor
	into @citem, @category

print '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CLEARED ITEMS (NO ACTION NEEDED)   
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'

WHILE @@FETCH_STATUS = 0
BEGIN
	begin
		if  @category = '000' or @category = '010' or @category = '050' or @category = '060' or @category = '110' or @category = '120'
			print @citem
		else
		begin
			print cast (@ccount as varchar(2)) + '. ' + @citem 
			set @ccount += 1
		end
	end
	
	FETCH NEXT FROM Cleared_Cursor
		into @citem, @category
END
		   
CLOSE Cleared_Cursor
DEALLOCATE Cleared_Cursor


/* this is the code to run the index fragmentation on a different database, if needed */
print '




STOP !!!!!

X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
	
THE FOLLOWING IS NOT FOR THE CUSTOMER AND NOT TO BE INCLUDED IN REVIEW . . .
.

.

.

*** THIS IS PROVIDED IN CASE YOU WANT TO RUN THE INDEX FRAGMENTATION SCRIPT AGAINST ANOTHER DATABASE WITHOUT RUNNING THE WHOLE SCRIPT AGAIN ***

'
print(@sqlfrag)	--in case you want to run it against another database without running the whole script again

select * from #ActionableItems order by category
select * from #ClearedItems order by category


--=================================================================================================
--CLEANUP OUTPUT TABLES
drop table #ActionableItems
drop table #ClearedItems


--=================================================================================================
--IN CASE THE SCRIPT FAILS, PLEASE RUN THE FOLLOWING
/*
this isn't necessarily needed as the temp tables should drop once the session is closed
but leaving here in case someone wants to run it again in the same session after a failure
*/

/*
IF OBJECT_ID('tempdb..#ActionableItems') IS NOT NULL
	drop table #ActionableItems

IF OBJECT_ID('tempdb..#ClearedItems') IS NOT NULL
	drop table #ClearedItems

if object_id('tempdb..#WhereIsFullText') IS NOT NULL
	DROP TABLE #WhereIsFullText

IF OBJECT_ID('tempdb..#FlagStatus') IS NOT NULL
   drop table #FlagStatus

IF OBJECT_ID('tempdb..#v2k16sp1stage1') IS NOT NULL
	drop table #v2k16sp1stage1

IF OBJECT_ID('tempdb..#v2k16sp1stage2') IS NOT NULL
	drop table #v2k16sp1stage2

IF OBJECT_ID('tempdb..#v2k12sp4stage1') IS NOT NULL
	drop table #v2k12sp4stage1

IF OBJECT_ID('tempdb..#v2k12sp4stage2') IS NOT NULL
	drop table #v2k12sp4stage2

IF OBJECT_ID('tempdb..#vstage') IS NOT NULL
	drop table #vstage

IF OBJECT_ID('tempdb..#vresults') IS NOT NULL
	drop table #vresults

IF OBJECT_ID('tempdb..#vstage2') IS NOT NULL
	drop table #vstage2

IF OBJECT_ID('tempdb..#vresults2') IS NOT NULL
	drop table #vresults2

IF OBJECT_ID('tempdb..#old') IS NOT NULL
	drop table #old

IF OBJECT_ID('tempdb..#DefTrace') IS NOT NULL
	drop table #DefTrace

IF OBJECT_ID('tempdb..#tempDBCC') IS NOT NULL
	drop table #tempDBCC

IF OBJECT_ID('tempdb..#DBCCResults') IS NOT NULL
	drop table #DBCCResults

IF OBJECT_ID('tempdb..#oldDBCC') IS NOT NULL
	drop table #oldDBCC

IF OBJECT_ID('tempdb..#results') IS NOT NULL
	drop table #results

IF OBJECT_ID(N'tempdb..#TooManyNCIs') IS NOT NULL
	DROP TABLE #TooManyNCIs

IF OBJECT_ID(N'tempdb..#HeapsNoIdx') IS NOT NULL
	DROP TABLE #HeapsNoIdx

IF OBJECT_ID(N'tempdb..#HeapsWIdx') IS NOT NULL
	DROP TABLE #HeapsWIdx

IF OBJECT_ID(N'tempdb..#DupIdx') IS NOT NULL
	DROP TABLE #DupIdx

IF OBJECT_ID('tempDB.dbo.#HypotheticalIndexDropScript') IS NOT NULL
	DROP TABLE #HypotheticalIndexDropScript;

IF OBJECT_ID('tempdb.dbo.#IndexFrag') IS NOT NULL
	DROP TABLE #IndexFrag

IF OBJECT_ID('tempdb.dbo.#statsCheck') IS NOT NULL
	DROP TABLE #statsCheck

IF OBJECT_ID('tempdb.dbo.#missingIdxDMV') IS NOT NULL
	DROP TABLE #missingIdxDMV

IF OBJECT_ID('tempdb.dbo.#missingIdxCache') IS NOT NULL
	DROP TABLE #missingIdxCache

IF OBJECT_ID('tempdb.dbo.#mostCPUsps') IS NOT NULL
	DROP TABLE #mostCPUsps

IF OBJECT_ID('tempdb.dbo.#mostIOsps') IS NOT NULL
	DROP TABLE #mostIOsps

IF OBJECT_ID('tempdb.dbo.#longestTimeSPs') IS NOT NULL
	DROP TABLE #longestTimeSPs
*/
--=================================================================================================